hello and welcome to the dunker for

3
00:00:14,330 --> 00:00:16,550
beginners course my name is moon shot 1

4
00:00:16,550 --> 00:00:18,289
omelette and I will be your instructor

5
00:00:18,289 --> 00:00:21,410
for this course I'm a DevOps and cloud

6
00:00:21,410 --> 00:00:24,080
trainer at code cloud comm which is an

7
00:00:24,080 --> 00:00:26,119
interactive hands-on online learning

8
00:00:26,119 --> 00:00:28,519
platform I've been working in the

9
00:00:28,519 --> 00:00:30,289
industry as a consultant for over

10
00:00:30,289 --> 00:00:32,479
thirteen years and have helped hundreds

11
00:00:32,479 --> 00:00:34,550
of thousands of students learn

12
00:00:34,550 --> 00:00:37,039
technology in a fun and interactive way

13
00:00:37,039 --> 00:00:39,469
in this course you will learn docker

14
00:00:39,469 --> 00:00:42,019
through a series of lectures that use

15
00:00:42,019 --> 00:00:44,479
animation illustration and some fun

16
00:00:44,479 --> 00:00:47,569
analogies that simplify complex concepts

17
00:00:47,569 --> 00:00:49,969
we have demos that will show you how to

18
00:00:49,969 --> 00:00:52,010
install and get started with docker and

19
00:00:52,010 --> 00:00:54,739
most importantly we have hands-on labs

20
00:00:54,739 --> 00:00:56,929
that you can access right in your

21
00:00:56,929 --> 00:00:59,269
browser I will explain more about it in

22
00:00:59,269 --> 00:01:01,369
a bit but first let's look at the

23
00:01:01,369 --> 00:01:03,979
objectives of this course in this course

24
00:01:03,979 --> 00:01:05,689
we first try to understand what

25
00:01:05,689 --> 00:01:08,630
containers are what docker is and why

26
00:01:08,630 --> 00:01:10,460
you might need it and what it can do for

27
00:01:10,460 --> 00:01:13,039
you we will see how to run a docker

28
00:01:13,039 --> 00:01:15,079
container how to build your own docker

29
00:01:15,079 --> 00:01:17,750
image we will see networking in docker

30
00:01:17,750 --> 00:01:20,299
and how to use docker compose what

31
00:01:20,299 --> 00:01:22,250
docker registry is how to deploy your

32
00:01:22,250 --> 00:01:24,770
own private registry and we then look at

33
00:01:24,770 --> 00:01:27,289
some of these concepts in debt and we

34
00:01:27,289 --> 00:01:28,969
try to understand how docker really

35
00:01:28,969 --> 00:01:31,579
works under the hood we look at docker

36
00:01:31,579 --> 00:01:34,070
for Windows and Mac before finally

37
00:01:34,070 --> 00:01:35,899
getting a basic introduction to

38
00:01:35,899 --> 00:01:39,049
container orchestration tools like dr.

39
00:01:39,049 --> 00:01:41,390
Swann and kubernetes here's a quick note

40
00:01:41,390 --> 00:01:43,850
about hands-on labs first of all to

41
00:01:43,850 --> 00:01:45,710
complete this course you don't have to

42
00:01:45,710 --> 00:01:48,170
set up your own labs well you may set it

43
00:01:48,170 --> 00:01:50,600
up if you wish to if you wish to have

44
00:01:50,600 --> 00:01:52,520
your own environment and we have a demo

45
00:01:52,520 --> 00:01:55,130
as well but as part of this course we

46
00:01:55,130 --> 00:01:57,350
provide real labs that you can access

47
00:01:57,350 --> 00:02:00,049
right in your browser anywhere anytime

48
00:02:00,049 --> 00:02:01,939
and as many times as you want

49
00:02:01,939 --> 00:02:04,880
the labs give you instant access to a

50
00:02:04,880 --> 00:02:07,219
terminal to a docker host and an

51
00:02:07,219 --> 00:02:09,860
accompanying quiz portal the quiz portal

52
00:02:09,860 --> 00:02:11,030
asks a set of

53
00:02:11,030 --> 00:02:12,530
questions such as exploring the

54
00:02:12,530 --> 00:02:14,900
environment and gathering information or

55
00:02:14,900 --> 00:02:17,300
you might be asked to perform an action

56
00:02:17,300 --> 00:02:19,970
such as run docker container the quiz

57
00:02:19,970 --> 00:02:21,920
portal then validates your work and

58
00:02:21,920 --> 00:02:24,560
gives you feedback instantly every

59
00:02:24,560 --> 00:02:26,900
lecture in this course is accompanied by

60
00:02:26,900 --> 00:02:29,300
such challenging interactive quizzes

61
00:02:29,300 --> 00:02:31,790
that makes learning docker a fun

62
00:02:31,790 --> 00:02:35,120
activity so I hope you're as thrilled as

63
00:02:35,120 --> 00:02:38,640
I am to get started so let us begin

64
00:02:38,640 --> 00:02:42,430
[Music]

65
00:02:42,430 --> 00:02:44,690
we're going to start by looking at a

66
00:02:44,690 --> 00:02:46,790
high-level overview on why you need

67
00:02:46,790 --> 00:02:49,730
docker and what it can do for you let me

68
00:02:49,730 --> 00:02:51,830
start by sharing how I got introduced to

69
00:02:51,830 --> 00:02:54,470
Locker in one of my previous projects I

70
00:02:54,470 --> 00:02:56,540
had this requirement to set up an

71
00:02:56,540 --> 00:02:58,760
end-to-end application stack including

72
00:02:58,760 --> 00:03:01,250
various different technologies like a

73
00:03:01,250 --> 00:03:03,800
web server using node.js and a database

74
00:03:03,800 --> 00:03:06,380
such as MongoDB and a messaging system

75
00:03:06,380 --> 00:03:08,900
like Redis and an orchestration tool

76
00:03:08,900 --> 00:03:11,090
like ansible we had a lot of issues

77
00:03:11,090 --> 00:03:13,550
developing this application stack with

78
00:03:13,550 --> 00:03:16,100
all these different components first of

79
00:03:16,100 --> 00:03:17,870
all their compatibility with the

80
00:03:17,870 --> 00:03:20,180
underlying OS was an issue we had to

81
00:03:20,180 --> 00:03:22,489
ensure that all these different services

82
00:03:22,489 --> 00:03:25,280
were compatible with the version of OS

83
00:03:25,280 --> 00:03:27,320
we were planning to use there have been

84
00:03:27,320 --> 00:03:29,360
times when certain version of these

85
00:03:29,360 --> 00:03:31,579
services were not compatible with the OS

86
00:03:31,579 --> 00:03:33,799
and we've had to go back and look at

87
00:03:33,799 --> 00:03:36,019
different OS that was compatible with

88
00:03:36,019 --> 00:03:38,750
all of these different services secondly

89
00:03:38,750 --> 00:03:40,489
we had to check the compatibility

90
00:03:40,489 --> 00:03:43,100
between these services and the libraries

91
00:03:43,100 --> 00:03:45,829
and dependencies on the OS we've had

92
00:03:45,829 --> 00:03:48,380
issues where one service requires one

93
00:03:48,380 --> 00:03:50,660
version of a dependent library whereas

94
00:03:50,660 --> 00:03:52,820
another service requires another version

95
00:03:52,820 --> 00:03:55,489
the architecture of our application

96
00:03:55,489 --> 00:03:57,950
changed over time we've had to upgrade

97
00:03:57,950 --> 00:04:00,200
to newer versions of these components or

98
00:04:00,200 --> 00:04:03,200
change the database etc and every time

99
00:04:03,200 --> 00:04:05,540
something changed we had to go through

100
00:04:05,540 --> 00:04:07,430
the same process of checking

101
00:04:07,430 --> 00:04:09,230
compatibility between these various

102
00:04:09,230 --> 00:04:11,420
components and the underlying

103
00:04:11,420 --> 00:04:14,630
infrastructure this compatibility matrix

104
00:04:14,630 --> 00:04:17,149
issue is usually referred to as the

105
00:04:17,149 --> 00:04:20,988
matrix from hell next every time we had

106
00:04:20,988 --> 00:04:23,570
a new developer on board we found it

107
00:04:23,570 --> 00:04:24,950
really difficult to

108
00:04:24,950 --> 00:04:27,530
a new environment the new developers had

109
00:04:27,530 --> 00:04:29,750
to follow a large set of instructions

110
00:04:29,750 --> 00:04:32,030
and run hundreds of commands to finally

111
00:04:32,030 --> 00:04:33,890
set up their environments we had to make

112
00:04:33,890 --> 00:04:35,930
sure they were using the right operating

113
00:04:35,930 --> 00:04:38,090
system the right versions of each of

114
00:04:38,090 --> 00:04:40,430
these components and each developer had

115
00:04:40,430 --> 00:04:42,670
to set all that up by himself each time

116
00:04:42,670 --> 00:04:45,980
we also had different development tests

117
00:04:45,980 --> 00:04:48,320
and production environments one

118
00:04:48,320 --> 00:04:50,150
developer may be comfortable using one

119
00:04:50,150 --> 00:04:52,250
OS and the others may be comfortable

120
00:04:52,250 --> 00:04:54,470
using another one and so we couldn't

121
00:04:54,470 --> 00:04:56,600
guarantee that the application that we

122
00:04:56,600 --> 00:04:58,940
were building would run the same way in

123
00:04:58,940 --> 00:05:01,070
different environments and so all of

124
00:05:01,070 --> 00:05:03,470
this made our life in developing

125
00:05:03,470 --> 00:05:06,140
building and shipping the application

126
00:05:06,140 --> 00:05:08,990
really difficult so I needed something

127
00:05:08,990 --> 00:05:10,640
that could help us with the

128
00:05:10,640 --> 00:05:12,530
compatibility issue and something that

129
00:05:12,530 --> 00:05:15,320
will allow us to modify or change these

130
00:05:15,320 --> 00:05:17,420
components without affecting the other

131
00:05:17,420 --> 00:05:19,280
components and even modify the

132
00:05:19,280 --> 00:05:21,410
underlying operating systems as required

133
00:05:21,410 --> 00:05:25,310
and that search landed me on docker with

134
00:05:25,310 --> 00:05:28,610
docker I was able to run each component

135
00:05:28,610 --> 00:05:31,130
in a separate container with its own

136
00:05:31,130 --> 00:05:34,700
dependencies and its own libraries all

137
00:05:34,700 --> 00:05:37,340
on the same VM and the OS but within

138
00:05:37,340 --> 00:05:40,100
separate environments or containers we

139
00:05:40,100 --> 00:05:41,510
just had to build the docker

140
00:05:41,510 --> 00:05:43,790
configuration once and all our

141
00:05:43,790 --> 00:05:45,800
developers could now get started with a

142
00:05:45,800 --> 00:05:48,440
simple docker run command a respective

143
00:05:48,440 --> 00:05:50,120
of what the underlying operating system

144
00:05:50,120 --> 00:05:52,820
they run all they needed to do was to

145
00:05:52,820 --> 00:05:54,680
make sure they had duck or installed on

146
00:05:54,680 --> 00:05:57,040
their systems so what are containers

147
00:05:57,040 --> 00:05:59,900
containers are completely isolated

148
00:05:59,900 --> 00:06:01,790
environments I think they can have their

149
00:06:01,790 --> 00:06:04,250
own processes for services their own

150
00:06:04,250 --> 00:06:06,890
network interfaces their own mounts just

151
00:06:06,890 --> 00:06:08,900
like washing machines except they all

152
00:06:08,900 --> 00:06:12,200
share the same OS kernel we will look at

153
00:06:12,200 --> 00:06:14,150
what that means in a bit but it's also

154
00:06:14,150 --> 00:06:16,040
important to note that containers are

155
00:06:16,040 --> 00:06:18,260
not new with docker containers have

156
00:06:18,260 --> 00:06:20,570
existed for about 10 years now and some

157
00:06:20,570 --> 00:06:22,310
of the different types of containers are

158
00:06:22,310 --> 00:06:26,840
LX c LX d LX c FS etc docker utilizes

159
00:06:26,840 --> 00:06:29,030
Aleksey containers setting up these

160
00:06:29,030 --> 00:06:31,160
continua environments is hard as they

161
00:06:31,160 --> 00:06:32,810
are very low-level and that is where

162
00:06:32,810 --> 00:06:35,510
docker offers a high-level tool with

163
00:06:35,510 --> 00:06:37,970
several powerful functionalities making

164
00:06:37,970 --> 00:06:38,820
it really easy

165
00:06:38,820 --> 00:06:42,030
for end-users like us to understand how

166
00:06:42,030 --> 00:06:44,550
docker works let us revisit some basic

167
00:06:44,550 --> 00:06:47,310
concepts of operating systems first if

168
00:06:47,310 --> 00:06:48,720
you look at operating systems like

169
00:06:48,720 --> 00:06:52,050
Ubuntu Fedora Susi air scent OS they all

170
00:06:52,050 --> 00:06:55,500
consist of two things an OS kernel and a

171
00:06:55,500 --> 00:06:58,200
set of software the OS kernel is

172
00:06:58,200 --> 00:07:00,060
responsible for interacting with the

173
00:07:00,060 --> 00:07:02,250
underlying hardware while the OS kernel

174
00:07:02,250 --> 00:07:04,290
remains the same which is Linux in this

175
00:07:04,290 --> 00:07:06,690
case it's the software above it that

176
00:07:06,690 --> 00:07:08,420
makes these operating systems different

177
00:07:08,420 --> 00:07:11,610
this software may consist of a different

178
00:07:11,610 --> 00:07:14,100
user interface drivers compilers file

179
00:07:14,100 --> 00:07:17,130
managers developer tools etc so you have

180
00:07:17,130 --> 00:07:19,920
a common Linux kernel shared across all

181
00:07:19,920 --> 00:07:22,500
races and some custom software that

182
00:07:22,500 --> 00:07:24,390
differentiate operating systems from

183
00:07:24,390 --> 00:07:27,450
each other we said earlier that docker

184
00:07:27,450 --> 00:07:29,670
containers share the underlying kernel

185
00:07:29,670 --> 00:07:31,320
so what does that actually mean

186
00:07:31,320 --> 00:07:33,960
sharing the kernel let's say we have a

187
00:07:33,960 --> 00:07:36,510
system with an Ubuntu OS with docker

188
00:07:36,510 --> 00:07:39,210
installed on it docker can run any

189
00:07:39,210 --> 00:07:41,970
flavor of OS on top of it as long as

190
00:07:41,970 --> 00:07:44,250
they are all based on the same kernel in

191
00:07:44,250 --> 00:07:47,730
this case Linux if the underlying OS is

192
00:07:47,730 --> 00:07:50,310
Ubuntu docker can run a container based

193
00:07:50,310 --> 00:07:52,500
on another distribution like debian

194
00:07:52,500 --> 00:07:55,890
fedora SUSE or Sint OS each docker

195
00:07:55,890 --> 00:07:58,230
container only has the additional

196
00:07:58,230 --> 00:08:00,360
software that we just talked about in

197
00:08:00,360 --> 00:08:02,190
the previous slide that makes these

198
00:08:02,190 --> 00:08:04,470
operating systems different and docker

199
00:08:04,470 --> 00:08:06,690
utilizes the underlying kernel of the

200
00:08:06,690 --> 00:08:09,480
docker host which works with all OSS

201
00:08:09,480 --> 00:08:12,810
above so what is an OS that do not share

202
00:08:12,810 --> 00:08:16,290
the same kernel as this Windows and so

203
00:08:16,290 --> 00:08:18,450
you won't be able to run a Windows based

204
00:08:18,450 --> 00:08:21,150
container on a docker host with Linux on

205
00:08:21,150 --> 00:08:24,180
it for that you will require a docker on

206
00:08:24,180 --> 00:08:26,940
a Windows server now it is when I say

207
00:08:26,940 --> 00:08:29,790
this that most of my students go hey

208
00:08:29,790 --> 00:08:32,400
hold on there that's not true and they

209
00:08:32,400 --> 00:08:33,929
install docker on Windows run a

210
00:08:33,929 --> 00:08:36,419
container based on Linux and go see it's

211
00:08:36,419 --> 00:08:39,690
possible well when you install docker on

212
00:08:39,690 --> 00:08:42,179
Windows and run a Linux container on

213
00:08:42,179 --> 00:08:44,580
Windows you're not really running a

214
00:08:44,580 --> 00:08:46,980
Linux container on Windows Windows runs

215
00:08:46,980 --> 00:08:49,560
a Linux container on a Linux virtual

216
00:08:49,560 --> 00:08:51,900
machine under the hood so it's really

217
00:08:51,900 --> 00:08:52,740
Linux

218
00:08:52,740 --> 00:08:54,810
container on Linux virtual machine on

219
00:08:54,810 --> 00:08:57,360
Windows we discuss more about this on

220
00:08:57,360 --> 00:09:00,750
the docker on Windows or Mac later

221
00:09:00,750 --> 00:09:03,779
during this course now you might ask

222
00:09:03,779 --> 00:09:06,149
isn't that a disadvantage then not being

223
00:09:06,149 --> 00:09:09,690
able to run another kernel on the OS the

224
00:09:09,690 --> 00:09:11,940
answer is no because unlike hypervisors

225
00:09:11,940 --> 00:09:14,520
docker is not meant to virtualize and

226
00:09:14,520 --> 00:09:16,110
run different operating systems and

227
00:09:16,110 --> 00:09:18,600
kernels on the same hardware the main

228
00:09:18,600 --> 00:09:21,300
purpose of docker is to package and

229
00:09:21,300 --> 00:09:23,790
container as applications and to ship

230
00:09:23,790 --> 00:09:26,370
them and to run them anywhere any times

231
00:09:26,370 --> 00:09:29,790
as many times as you want so that brings

232
00:09:29,790 --> 00:09:32,040
us to the differences between virtual

233
00:09:32,040 --> 00:09:34,170
machines and containers something that

234
00:09:34,170 --> 00:09:36,089
we tend to do is specially those from a

235
00:09:36,089 --> 00:09:38,670
virtualization background as you can see

236
00:09:38,670 --> 00:09:41,190
on the right in case of docker we have

237
00:09:41,190 --> 00:09:43,560
the underlying hardware infrastructure

238
00:09:43,560 --> 00:09:45,870
and then the OS and then docker

239
00:09:45,870 --> 00:09:48,480
installed on the OS docker then manages

240
00:09:48,480 --> 00:09:50,610
the containers that run with libraries

241
00:09:50,610 --> 00:09:53,070
and dependencies alone in case of

242
00:09:53,070 --> 00:09:55,140
virtual machines we have the hypervisor

243
00:09:55,140 --> 00:09:58,410
like ESX on the hardware and then the

244
00:09:58,410 --> 00:10:00,779
virtual machines on them as you can see

245
00:10:00,779 --> 00:10:03,149
each virtual machine has its own OS

246
00:10:03,149 --> 00:10:05,520
inside it and then the dependencies and

247
00:10:05,520 --> 00:10:08,490
then the application the overhead causes

248
00:10:08,490 --> 00:10:10,320
higher utilization of underlying

249
00:10:10,320 --> 00:10:12,510
resources as there are multiple virtual

250
00:10:12,510 --> 00:10:15,300
operating systems and kernel running the

251
00:10:15,300 --> 00:10:17,339
virtual machines also consume higher

252
00:10:17,339 --> 00:10:20,670
disk space as each VM is heavy and is

253
00:10:20,670 --> 00:10:22,800
usually in gigabytes in size whereas

254
00:10:22,800 --> 00:10:24,839
docker containers are lightweight and

255
00:10:24,839 --> 00:10:27,600
are usually in megabytes in size this

256
00:10:27,600 --> 00:10:29,370
allows docker containers to boot up

257
00:10:29,370 --> 00:10:31,620
faster usually in a matter of seconds

258
00:10:31,620 --> 00:10:34,560
whereas VMs as we know takes minutes to

259
00:10:34,560 --> 00:10:36,870
boot up as it needs to put up the entire

260
00:10:36,870 --> 00:10:39,750
operating system it is also important to

261
00:10:39,750 --> 00:10:42,540
note that docker has less isolation as

262
00:10:42,540 --> 00:10:44,490
more resources are shared between the

263
00:10:44,490 --> 00:10:46,050
containers like kernel

264
00:10:46,050 --> 00:10:48,899
whereas VMs have complete isolation from

265
00:10:48,899 --> 00:10:51,450
each other since VMs don't rely on the

266
00:10:51,450 --> 00:10:53,670
underlying OS or kernel you can run

267
00:10:53,670 --> 00:10:55,740
different types of applications built on

268
00:10:55,740 --> 00:10:58,140
different OSS such as Linux based or

269
00:10:58,140 --> 00:10:59,670
Windows based apps on the same

270
00:10:59,670 --> 00:11:02,579
hypervisor so those are some differences

271
00:11:02,579 --> 00:11:04,949
between the two now having said that

272
00:11:04,949 --> 00:11:06,210
it's not an

273
00:11:06,210 --> 00:11:08,130
either container or virtual machine

274
00:11:08,130 --> 00:11:10,529
situation its containers and virtual

275
00:11:10,529 --> 00:11:13,020
machines now when you have large

276
00:11:13,020 --> 00:11:14,640
environments with thousands of

277
00:11:14,640 --> 00:11:16,170
application containers running on

278
00:11:16,170 --> 00:11:18,810
thousands of dog or hosts you will often

279
00:11:18,810 --> 00:11:21,180
see containers provisioned on virtual

280
00:11:21,180 --> 00:11:24,480
docker hosts that way we can utilize the

281
00:11:24,480 --> 00:11:26,790
advantages of both technologies we can

282
00:11:26,790 --> 00:11:29,010
use the benefits of virtualization to

283
00:11:29,010 --> 00:11:31,080
easily provision or decommission docker

284
00:11:31,080 --> 00:11:33,360
House serves as required at the same

285
00:11:33,360 --> 00:11:35,490
time make use of the benefits of docker

286
00:11:35,490 --> 00:11:37,830
to easily provision applications and

287
00:11:37,830 --> 00:11:40,680
quickly scale them as required but

288
00:11:40,680 --> 00:11:42,990
remember that in this case we will not

289
00:11:42,990 --> 00:11:45,300
be provisioning that many virtual

290
00:11:45,300 --> 00:11:48,390
machines as we used to before because

291
00:11:48,390 --> 00:11:51,360
earlier we provisioned a virtual machine

292
00:11:51,360 --> 00:11:52,560
for each application

293
00:11:52,560 --> 00:11:54,660
now you might provision a virtual

294
00:11:54,660 --> 00:11:56,790
machine for hundreds or thousands of

295
00:11:56,790 --> 00:11:59,940
containers so how is it done there are

296
00:11:59,940 --> 00:12:02,250
lots of containerized versions of

297
00:12:02,250 --> 00:12:04,380
applications readily available as of

298
00:12:04,380 --> 00:12:06,690
today so most organizations have their

299
00:12:06,690 --> 00:12:09,060
products containerized and available in

300
00:12:09,060 --> 00:12:11,310
a public dock or repository called

301
00:12:11,310 --> 00:12:14,190
docker hub or docker store for example

302
00:12:14,190 --> 00:12:16,740
you can find images of most common

303
00:12:16,740 --> 00:12:19,170
operating systems databases and other

304
00:12:19,170 --> 00:12:21,810
services and tools once you identify the

305
00:12:21,810 --> 00:12:23,820
images you need and you install docker

306
00:12:23,820 --> 00:12:26,580
on your hosts bringing up an application

307
00:12:26,580 --> 00:12:29,550
is as easy as running a docker run

308
00:12:29,550 --> 00:12:31,440
command with the name of the image in

309
00:12:31,440 --> 00:12:33,690
this case running a docker run and

310
00:12:33,690 --> 00:12:35,430
single command will run an instance of

311
00:12:35,430 --> 00:12:36,000
ansible

312
00:12:36,000 --> 00:12:38,190
on the docker host similarly run an

313
00:12:38,190 --> 00:12:41,190
instance of MongoDB Redis and nodejs

314
00:12:41,190 --> 00:12:43,800
using the docker run command if we need

315
00:12:43,800 --> 00:12:45,900
to run multiple instances of the web

316
00:12:45,900 --> 00:12:48,779
service simply add as many instances as

317
00:12:48,779 --> 00:12:50,459
you need and configure a load balancer

318
00:12:50,459 --> 00:12:54,089
or some kind in the front in case one of

319
00:12:54,089 --> 00:12:55,950
the instances were to fail

320
00:12:55,950 --> 00:12:58,140
simply destroy that instance and launch

321
00:12:58,140 --> 00:13:01,020
anyone there are other solutions

322
00:13:01,020 --> 00:13:03,029
available for handling such cases that

323
00:13:03,029 --> 00:13:05,190
we will look at later during this course

324
00:13:05,190 --> 00:13:07,950
and for now don't focus too much on the

325
00:13:07,950 --> 00:13:10,140
commands and we will get to that in a

326
00:13:10,140 --> 00:13:13,950
bit we've been talking about images and

327
00:13:13,950 --> 00:13:15,839
containers let's understand the

328
00:13:15,839 --> 00:13:19,040
difference between the two an image is a

329
00:13:19,040 --> 00:13:21,259
package or a template just like a VM

330
00:13:21,259 --> 00:13:22,759
template that you might have worked with

331
00:13:22,759 --> 00:13:24,980
in the virtualization world it is used

332
00:13:24,980 --> 00:13:27,250
to create one or more containers

333
00:13:27,250 --> 00:13:30,110
containers are running instances of

334
00:13:30,110 --> 00:13:32,509
images that are isolated and have their

335
00:13:32,509 --> 00:13:34,600
own environments and set of processors

336
00:13:34,600 --> 00:13:36,529
as we've seen before

337
00:13:36,529 --> 00:13:38,660
a lot of products have been docker iced

338
00:13:38,660 --> 00:13:40,850
already in case you cannot find what

339
00:13:40,850 --> 00:13:42,440
you're looking for you could create your

340
00:13:42,440 --> 00:13:44,930
own image and push it to docker hub

341
00:13:44,930 --> 00:13:46,639
repository making it available for

342
00:13:46,639 --> 00:13:49,750
public so if you look at it

343
00:13:49,750 --> 00:13:52,279
traditionally developers developed

344
00:13:52,279 --> 00:13:54,529
applications then they hand it over to

345
00:13:54,529 --> 00:13:56,690
ops team to deploy and manage it in

346
00:13:56,690 --> 00:13:59,389
production environments they do that by

347
00:13:59,389 --> 00:14:01,579
providing a set of instructions such as

348
00:14:01,579 --> 00:14:03,920
information about how the hosts must be

349
00:14:03,920 --> 00:14:05,899
set up what prerequisites are to be

350
00:14:05,899 --> 00:14:07,279
installed on the host and how the

351
00:14:07,279 --> 00:14:09,639
dependencies are to be configured etc

352
00:14:09,639 --> 00:14:12,319
since the ops team did not really

353
00:14:12,319 --> 00:14:13,940
develop the application on their own

354
00:14:13,940 --> 00:14:16,579
they struggle with setting it up when

355
00:14:16,579 --> 00:14:18,019
the hidden issue they work with the

356
00:14:18,019 --> 00:14:21,350
developers to resolve it with docker the

357
00:14:21,350 --> 00:14:23,870
developers and operations teams work

358
00:14:23,870 --> 00:14:27,110
hand-in-hand to transform the guide into

359
00:14:27,110 --> 00:14:29,240
a docker file with both of their

360
00:14:29,240 --> 00:14:31,880
requirements this docker file is then

361
00:14:31,880 --> 00:14:33,529
used to create an image for their

362
00:14:33,529 --> 00:14:36,440
applications this image can now run on

363
00:14:36,440 --> 00:14:38,750
any host with docker installed on it and

364
00:14:38,750 --> 00:14:40,790
is guaranteed to run the same way

365
00:14:40,790 --> 00:14:43,339
everywhere so the ops team can now

366
00:14:43,339 --> 00:14:45,290
simply use the image to deploy the

367
00:14:45,290 --> 00:14:47,870
application since the image was already

368
00:14:47,870 --> 00:14:49,670
working when the developer built it and

369
00:14:49,670 --> 00:14:52,519
operations are have not modified it it

370
00:14:52,519 --> 00:14:54,949
continues to work the same way when

371
00:14:54,949 --> 00:14:57,529
deployed in production and that's one

372
00:14:57,529 --> 00:14:59,949
example of how a tool like docker

373
00:14:59,949 --> 00:15:03,319
contributes to the DevOps culture well

374
00:15:03,319 --> 00:15:05,600
that's it for now and in the upcoming

375
00:15:05,600 --> 00:15:07,459
lecture we will look at how to get

376
00:15:07,459 --> 00:15:15,199
started with docker we will now see how

377
00:15:15,199 --> 00:15:16,790
to get started with docker

378
00:15:16,790 --> 00:15:19,550
now docker has two editions the

379
00:15:19,550 --> 00:15:21,529
Community Edition and the Enterprise

380
00:15:21,529 --> 00:15:24,500
Edition the Community Edition is the set

381
00:15:24,500 --> 00:15:27,230
of free docker products the Enterprise

382
00:15:27,230 --> 00:15:29,569
Edition is the certified and supported

383
00:15:29,569 --> 00:15:31,880
container platform that comes with

384
00:15:31,880 --> 00:15:32,630
enterprise

385
00:15:32,630 --> 00:15:35,240
add ons like the image management image

386
00:15:35,240 --> 00:15:38,180
security Universal control plane for

387
00:15:38,180 --> 00:15:39,710
managing and orchestrating container

388
00:15:39,710 --> 00:15:42,320
runtimes but of course these come with a

389
00:15:42,320 --> 00:15:44,540
price we will discuss more about

390
00:15:44,540 --> 00:15:46,670
container orchestration later in this

391
00:15:46,670 --> 00:15:49,120
course and along with some alternatives

392
00:15:49,120 --> 00:15:51,800
for now we will go ahead with the

393
00:15:51,800 --> 00:15:54,650
Community Edition the Community Edition

394
00:15:54,650 --> 00:15:58,700
is available on Linux Mac Windows or on

395
00:15:58,700 --> 00:16:02,480
cloud platforms like AWS or Azure in the

396
00:16:02,480 --> 00:16:04,970
upcoming demo we will take a look at how

397
00:16:04,970 --> 00:16:07,040
to install and get started with docker

398
00:16:07,040 --> 00:16:10,970
on a Linux system now if you are on Mac

399
00:16:10,970 --> 00:16:13,490
or Windows you have two options either

400
00:16:13,490 --> 00:16:17,000
install a Linux VM using VirtualBox or

401
00:16:17,000 --> 00:16:19,340
some kind of virtualization platform and

402
00:16:19,340 --> 00:16:21,740
then follow along with the upcoming demo

403
00:16:21,740 --> 00:16:24,110
which is really the most easiest way to

404
00:16:24,110 --> 00:16:26,690
get started with docker the second

405
00:16:26,690 --> 00:16:29,360
option is to install docker Desktop for

406
00:16:29,360 --> 00:16:31,730
Mac or the docker desktop for Windows

407
00:16:31,730 --> 00:16:34,760
which are native applications so if that

408
00:16:34,760 --> 00:16:36,230
is really what you want

409
00:16:36,230 --> 00:16:38,570
check out the docker for Mac and the

410
00:16:38,570 --> 00:16:40,970
Windows sections towards the end of this

411
00:16:40,970 --> 00:16:43,790
course and then head back here once you

412
00:16:43,790 --> 00:16:46,580
are all set up we will now head over to

413
00:16:46,580 --> 00:16:49,100
a demo and we will take a look at how to

414
00:16:49,100 --> 00:16:54,200
install docker on a Linux machine in

415
00:16:54,200 --> 00:16:56,930
this demo we look at how to install and

416
00:16:56,930 --> 00:16:59,840
get started with docker first of all

417
00:16:59,840 --> 00:17:02,120
identify a system physical or virtual

418
00:17:02,120 --> 00:17:04,939
machine or laptop that has a supported

419
00:17:04,939 --> 00:17:07,550
operating system in my case I have an

420
00:17:07,550 --> 00:17:13,910
Ubuntu VM go to doctor comm and click on

421
00:17:13,910 --> 00:17:17,329
get darker you will be taken to the

422
00:17:17,329 --> 00:17:19,630
docker engine Community Edition page

423
00:17:19,630 --> 00:17:22,369
that is the free version that we are

424
00:17:22,369 --> 00:17:26,449
after from the left hand menu select

425
00:17:26,449 --> 00:17:30,620
your system type I choose Linux in my

426
00:17:30,620 --> 00:17:33,530
case and then select your OS flavor

427
00:17:33,530 --> 00:17:36,350
I choose Ubuntu read through the

428
00:17:36,350 --> 00:17:39,470
prerequisites and requirements your abun

429
00:17:39,470 --> 00:17:42,920
to system must be 64-bit and one of

430
00:17:42,920 --> 00:17:45,350
these supported versions like disco

431
00:17:45,350 --> 00:17:46,670
cosmic bio

432
00:17:46,670 --> 00:17:50,030
or Sanyal in my case I have a bionic

433
00:17:50,030 --> 00:17:54,980
version to confirm view the Etsy release

434
00:17:54,980 --> 00:18:00,620
file next uninstall any older version if

435
00:18:00,620 --> 00:18:04,280
one exists so let's just make sure that

436
00:18:04,280 --> 00:18:07,190
there is none on my host so I'll just

437
00:18:07,190 --> 00:18:09,800
copy and paste that command and I

438
00:18:09,800 --> 00:18:12,380
confirm that there are no older version

439
00:18:12,380 --> 00:18:16,370
that exists on my system the next step

440
00:18:16,370 --> 00:18:19,220
is to set up repository and install the

441
00:18:19,220 --> 00:18:22,130
software now there are two ways to go

442
00:18:22,130 --> 00:18:24,530
about this the first is using the

443
00:18:24,530 --> 00:18:27,440
package manager by first updating the

444
00:18:27,440 --> 00:18:29,780
repository using the apt-get update

445
00:18:29,780 --> 00:18:32,390
command then installing the prerequisite

446
00:18:32,390 --> 00:18:34,850
packages and then adding Dockers of

447
00:18:34,850 --> 00:18:36,980
facial GPG keys and then installing

448
00:18:36,980 --> 00:18:39,620
docker but I'm not going to go that

449
00:18:39,620 --> 00:18:43,220
route there is an easier way if you

450
00:18:43,220 --> 00:18:44,990
scroll all the way to the bottom you

451
00:18:44,990 --> 00:18:46,850
will find the instructions to install

452
00:18:46,850 --> 00:18:50,720
docker using the convenience script it's

453
00:18:50,720 --> 00:18:52,550
a script that automates the entire

454
00:18:52,550 --> 00:18:55,340
installation process and works on most

455
00:18:55,340 --> 00:18:58,580
operating systems run the first command

456
00:18:58,580 --> 00:19:01,040
to download a copy of the script and

457
00:19:01,040 --> 00:19:03,170
then run the second command to execute

458
00:19:03,170 --> 00:19:05,500
the script to install docker

459
00:19:05,500 --> 00:19:08,330
automatically give it a few minutes to

460
00:19:08,330 --> 00:19:11,080
complete the installation

461
00:19:16,720 --> 00:19:18,220
the

462
00:19:18,220 --> 00:19:20,770
is now successful that has now checked

463
00:19:20,770 --> 00:19:22,840
the version of docker using the darker

464
00:19:22,840 --> 00:19:26,039
version command we've installed version

465
00:19:26,039 --> 00:19:30,549
19.0 3.1 we will now run a simple

466
00:19:30,549 --> 00:19:32,620
container to ensure everything is

467
00:19:32,620 --> 00:19:36,010
working as expected for this head over

468
00:19:36,010 --> 00:19:39,789
to docker hub at hub docker calm here

469
00:19:39,789 --> 00:19:41,490
you will find a list of the most popular

470
00:19:41,490 --> 00:19:45,010
docker images like engine eggs MongoDB

471
00:19:45,010 --> 00:19:47,200
Alpine nodejs

472
00:19:47,200 --> 00:19:50,590
Redis etc let's search for a fun image

473
00:19:50,590 --> 00:19:54,190
called we'll say we'll say is Dockers

474
00:19:54,190 --> 00:19:57,070
version of cows a which is basically a

475
00:19:57,070 --> 00:19:59,340
simple application that trends a cow

476
00:19:59,340 --> 00:20:03,159
saying something in this case it happens

477
00:20:03,159 --> 00:20:05,980
to be a whale copy the docker run

478
00:20:05,980 --> 00:20:09,039
command given here remember to add a

479
00:20:09,039 --> 00:20:12,610
sudo and we will change the message to

480
00:20:12,610 --> 00:20:14,909
hello world

481
00:20:28,870 --> 00:20:31,539
on running this command docker pulls the

482
00:20:31,539 --> 00:20:33,880
image of the whales II application from

483
00:20:33,880 --> 00:20:37,570
docker hub and runs it and we have our

484
00:20:37,570 --> 00:20:43,380
avail saying hello great we're all set

485
00:20:43,380 --> 00:20:45,760
remember for the purpose of this course

486
00:20:45,760 --> 00:20:47,830
you don't really need to set up a docker

487
00:20:47,830 --> 00:20:48,820
system on your own

488
00:20:48,820 --> 00:20:51,130
we provide hands-on labs that you will

489
00:20:51,130 --> 00:20:53,350
get access to but if you wish to

490
00:20:53,350 --> 00:20:55,360
experiment on your own and follow along

491
00:20:55,360 --> 00:21:02,649
feel free to do so we now look at some

492
00:21:02,649 --> 00:21:04,570
of the docker commands at the end of

493
00:21:04,570 --> 00:21:05,950
this lecture you will go through a

494
00:21:05,950 --> 00:21:08,140
hands-on quiz where you will practice

495
00:21:08,140 --> 00:21:10,720
working with these commands let's start

496
00:21:10,720 --> 00:21:13,809
by looking at docker run command the

497
00:21:13,809 --> 00:21:15,669
docker run command is used to run a

498
00:21:15,669 --> 00:21:17,799
container from an image running the

499
00:21:17,799 --> 00:21:20,080
docker run nginx command will run an

500
00:21:20,080 --> 00:21:23,080
instance of the nginx application on the

501
00:21:23,080 --> 00:21:26,020
docker host if it already exists if the

502
00:21:26,020 --> 00:21:28,720
image is not present on the host it will

503
00:21:28,720 --> 00:21:31,000
go out to docker hub and pull the image

504
00:21:31,000 --> 00:21:33,610
down but this is only done the first

505
00:21:33,610 --> 00:21:36,220
time for the subsequent executions the

506
00:21:36,220 --> 00:21:39,429
same image will be reused the docker PS

507
00:21:39,429 --> 00:21:42,580
command lists all running containers and

508
00:21:42,580 --> 00:21:45,100
some basic information about them such

509
00:21:45,100 --> 00:21:47,110
as the container ID the name of the

510
00:21:47,110 --> 00:21:49,299
image we used to run the containers the

511
00:21:49,299 --> 00:21:51,070
current status and the name of the

512
00:21:51,070 --> 00:21:54,100
container each container automatically

513
00:21:54,100 --> 00:21:57,279
gets a random ID and name created for it

514
00:21:57,279 --> 00:22:00,190
by docker which in this case is silly

515
00:22:00,190 --> 00:22:03,520
Samet to see all containers running or

516
00:22:03,520 --> 00:22:07,360
not use the - a option this outputs all

517
00:22:07,360 --> 00:22:10,120
running as well as previously stopped or

518
00:22:10,120 --> 00:22:12,700
exited containers we will talk about the

519
00:22:12,700 --> 00:22:14,950
command and port fields shown in this

520
00:22:14,950 --> 00:22:17,230
output later in this course for now

521
00:22:17,230 --> 00:22:19,470
let's just focus on the basic commands

522
00:22:19,470 --> 00:22:22,210
to stop a running container use the

523
00:22:22,210 --> 00:22:24,520
Tucker stop command but you must provide

524
00:22:24,520 --> 00:22:26,860
either the container ID or the continue

525
00:22:26,860 --> 00:22:29,169
name in the stop command if you're not

526
00:22:29,169 --> 00:22:31,120
sure of the name run the docker PS

527
00:22:31,120 --> 00:22:34,149
command to get it on success you will

528
00:22:34,149 --> 00:22:35,950
see the name printed out and running

529
00:22:35,950 --> 00:22:38,799
docker PS again will show no running

530
00:22:38,799 --> 00:22:42,179
containers running docker PS - a

531
00:22:42,179 --> 00:22:44,429
however shows the container silly summit

532
00:22:44,429 --> 00:22:47,549
and that it is in an accident states a

533
00:22:47,549 --> 00:22:51,330
few seconds ago now what if we don't

534
00:22:51,330 --> 00:22:53,070
want this container lying around

535
00:22:53,070 --> 00:22:55,320
consuming space what if we want to get

536
00:22:55,320 --> 00:22:58,649
rid of it for good use the docker RM

537
00:22:58,649 --> 00:23:01,230
command to remove a stopped or exited

538
00:23:01,230 --> 00:23:04,350
container permanently if it prints the

539
00:23:04,350 --> 00:23:06,659
name back we're good run the docker PS

540
00:23:06,659 --> 00:23:09,119
command again to verify that it's no

541
00:23:09,119 --> 00:23:12,149
longer present good but what about the

542
00:23:12,149 --> 00:23:14,999
nginx image that was downloaded at first

543
00:23:14,999 --> 00:23:17,460
we're not using that anymore so how do

544
00:23:17,460 --> 00:23:20,970
we get rid of that image but first how

545
00:23:20,970 --> 00:23:23,490
do we see a list of images present on

546
00:23:23,490 --> 00:23:26,129
our hosts run the docker images command

547
00:23:26,129 --> 00:23:28,470
to see a list of available images and

548
00:23:28,470 --> 00:23:31,110
their sizes on our hosts we have four

549
00:23:31,110 --> 00:23:34,470
images the nginx Redis Ubuntu and Alpine

550
00:23:34,470 --> 00:23:37,259
we will talk about tags later in this

551
00:23:37,259 --> 00:23:40,860
course when we discuss about images to

552
00:23:40,860 --> 00:23:43,200
remove an image that you no longer plan

553
00:23:43,200 --> 00:23:46,369
to use run the docker RM I command

554
00:23:46,369 --> 00:23:49,110
remember you must ensure that no

555
00:23:49,110 --> 00:23:51,299
containers are running off of that image

556
00:23:51,299 --> 00:23:53,190
before attempting to remove the image

557
00:23:53,190 --> 00:23:56,009
you must stop and delete all dependent

558
00:23:56,009 --> 00:23:58,669
containers to be able to delete an image

559
00:23:58,669 --> 00:24:01,619
when we ran the docker run command

560
00:24:01,619 --> 00:24:04,529
earlier it downloaded the Ubuntu image

561
00:24:04,529 --> 00:24:07,710
as it couldn't find one locally what if

562
00:24:07,710 --> 00:24:10,049
we simply want to download the image and

563
00:24:10,049 --> 00:24:13,139
keep so when we run the run docker run

564
00:24:13,139 --> 00:24:15,509
command we don't want to wait for it to

565
00:24:15,509 --> 00:24:18,929
download use the docker pull command to

566
00:24:18,929 --> 00:24:21,389
only pull the image and not run the

567
00:24:21,389 --> 00:24:23,129
container so in this case the docker

568
00:24:23,129 --> 00:24:26,039
pull a bull to come and pulls the Ubuntu

569
00:24:26,039 --> 00:24:29,460
image and stores it on our host let's

570
00:24:29,460 --> 00:24:31,769
look at another example say you were to

571
00:24:31,769 --> 00:24:33,779
run a docker container from an Ubuntu

572
00:24:33,779 --> 00:24:36,659
image when you run the docker run Ubuntu

573
00:24:36,659 --> 00:24:39,179
command it runs an instance of a bundle

574
00:24:39,179 --> 00:24:42,240
image and exits immediately if you were

575
00:24:42,240 --> 00:24:44,070
to list the running containers you

576
00:24:44,070 --> 00:24:45,809
wouldn't see the container running if

577
00:24:45,809 --> 00:24:47,669
you list all containers including those

578
00:24:47,669 --> 00:24:49,830
that are stopped you will see that the

579
00:24:49,830 --> 00:24:52,769
new container Iran is in an exited state

580
00:24:52,769 --> 00:24:55,310
now why is that

581
00:24:55,310 --> 00:24:58,310
unlike virtual machines containers are

582
00:24:58,310 --> 00:25:00,880
not meant to host an operating system

583
00:25:00,880 --> 00:25:04,160
containers are meant to run a specific

584
00:25:04,160 --> 00:25:06,920
task or process such as to host an

585
00:25:06,920 --> 00:25:08,990
instance of a web server or application

586
00:25:08,990 --> 00:25:11,510
server or a database or simply to carry

587
00:25:11,510 --> 00:25:14,270
some kind of computation or analysis

588
00:25:14,270 --> 00:25:17,630
tasks once the task is complete the

589
00:25:17,630 --> 00:25:21,290
container exits a container only lives

590
00:25:21,290 --> 00:25:23,810
as long as the process inside it is

591
00:25:23,810 --> 00:25:26,210
alive if the web service inside the

592
00:25:26,210 --> 00:25:29,060
container is stopped or crash then the

593
00:25:29,060 --> 00:25:32,180
container exits this is why when you run

594
00:25:32,180 --> 00:25:34,370
a container from an Ubuntu image it

595
00:25:34,370 --> 00:25:37,190
stops immediately because you bun too is

596
00:25:37,190 --> 00:25:39,020
just an image of an operating system

597
00:25:39,020 --> 00:25:42,050
that is used as the base image for other

598
00:25:42,050 --> 00:25:44,540
applications there is no process or

599
00:25:44,540 --> 00:25:47,780
application running in it by default if

600
00:25:47,780 --> 00:25:50,660
the image isn't running any service as

601
00:25:50,660 --> 00:25:52,880
is the case with Ubuntu you could

602
00:25:52,880 --> 00:25:55,970
instruct docker to run a process with

603
00:25:55,970 --> 00:25:58,280
the docker run command for example a

604
00:25:58,280 --> 00:26:00,650
sleep command with a duration of 5

605
00:26:00,650 --> 00:26:03,500
seconds when the container starts it

606
00:26:03,500 --> 00:26:05,660
runs the sleep command and goes into

607
00:26:05,660 --> 00:26:09,080
sleep for 5 seconds post with the sleep

608
00:26:09,080 --> 00:26:11,620
command exits and the container stops

609
00:26:11,620 --> 00:26:14,630
what we just saw was executing a command

610
00:26:14,630 --> 00:26:17,360
when we run the container but what if we

611
00:26:17,360 --> 00:26:19,040
would like to execute a command on a

612
00:26:19,040 --> 00:26:22,010
running container for example when I run

613
00:26:22,010 --> 00:26:23,960
the docker PS command I can see that

614
00:26:23,960 --> 00:26:26,600
there is a running container which uses

615
00:26:26,600 --> 00:26:29,570
the bun to image and sleeps 400 seconds

616
00:26:29,570 --> 00:26:32,150
so let's say I would like to see the

617
00:26:32,150 --> 00:26:34,130
contents of a file inside this

618
00:26:34,130 --> 00:26:36,620
particular container I could use the

619
00:26:36,620 --> 00:26:39,500
docker exec command to execute a command

620
00:26:39,500 --> 00:26:42,290
on my docker container in this case to

621
00:26:42,290 --> 00:26:45,830
print the contents of the Etsy hosts

622
00:26:45,830 --> 00:26:49,220
file finally let's look at one more

623
00:26:49,220 --> 00:26:50,900
option before we head over to the

624
00:26:50,900 --> 00:26:53,870
practice exercises I'm now going to run

625
00:26:53,870 --> 00:26:56,300
a docker image I developed for a simple

626
00:26:56,300 --> 00:26:59,150
web application the repository name is

627
00:26:59,150 --> 00:27:02,690
called cloud slash simple web app it

628
00:27:02,690 --> 00:27:04,910
runs a simple web server that listens on

629
00:27:04,910 --> 00:27:08,330
port 8080 when you run a docker

630
00:27:08,330 --> 00:27:10,610
c'mon like this it runs in the

631
00:27:10,610 --> 00:27:12,799
foreground or in an attached mode

632
00:27:12,799 --> 00:27:15,620
meaning you will be attached to the

633
00:27:15,620 --> 00:27:17,929
console or the standard out of the

634
00:27:17,929 --> 00:27:19,909
docker container and you will see the

635
00:27:19,909 --> 00:27:22,360
output of the web service on your screen

636
00:27:22,360 --> 00:27:25,039
you won't be able to do anything else on

637
00:27:25,039 --> 00:27:26,690
this console other than view the output

638
00:27:26,690 --> 00:27:29,630
until this docker container stops it

639
00:27:29,630 --> 00:27:32,990
won't respond to your inputs press the

640
00:27:32,990 --> 00:27:36,140
ctrl + C combination to stop the

641
00:27:36,140 --> 00:27:38,450
container and the application hosted on

642
00:27:38,450 --> 00:27:41,210
the container exits and you get back to

643
00:27:41,210 --> 00:27:45,320
your prompt another option is to run the

644
00:27:45,320 --> 00:27:48,110
docker container in the D test mode by

645
00:27:48,110 --> 00:27:52,100
providing the - D option this will run

646
00:27:52,100 --> 00:27:54,049
the docker container in the background

647
00:27:54,049 --> 00:27:56,299
mode and you will be back to your prompt

648
00:27:56,299 --> 00:27:59,059
immediately the container will continue

649
00:27:59,059 --> 00:28:01,700
to run in the back end run the docker PS

650
00:28:01,700 --> 00:28:04,690
command to view the running container

651
00:28:04,690 --> 00:28:07,580
now if you would like to attach back to

652
00:28:07,580 --> 00:28:10,250
the running container later run the

653
00:28:10,250 --> 00:28:12,590
docker attach command and specify the

654
00:28:12,590 --> 00:28:15,769
name or ID of the docker container now

655
00:28:15,769 --> 00:28:18,320
remember if you are specifying the ID of

656
00:28:18,320 --> 00:28:21,350
a container in any docker command you

657
00:28:21,350 --> 00:28:23,360
can simply provide the first few

658
00:28:23,360 --> 00:28:25,880
characters alone just so it is different

659
00:28:25,880 --> 00:28:28,100
from the other container IDs on the host

660
00:28:28,100 --> 00:28:34,399
in this case I specify a 0 for 3 D now

661
00:28:34,399 --> 00:28:36,529
don't worry about accessing the UI of

662
00:28:36,529 --> 00:28:39,080
the webserver for now we will look more

663
00:28:39,080 --> 00:28:41,720
into that in the upcoming lectures for

664
00:28:41,720 --> 00:28:43,279
now let's just understand the basic

665
00:28:43,279 --> 00:28:45,799
commands will now get our hands dirty

666
00:28:45,799 --> 00:28:48,440
with the docker CLI so let's take a look

667
00:28:48,440 --> 00:28:50,600
at how to access the practice lab

668
00:28:50,600 --> 00:28:53,769
environments next

669
00:28:55,250 --> 00:28:58,440
let me now walk you through the hands-on

670
00:28:58,440 --> 00:29:01,919
lab practice environment the links to

671
00:29:01,919 --> 00:29:04,139
access the labs associated with this

672
00:29:04,139 --> 00:29:06,809
course are available at cold cloud at

673
00:29:06,809 --> 00:29:10,409
code cloud comm slash P slash docker

674
00:29:10,409 --> 00:29:13,320
dash labs this link is also given in the

675
00:29:13,320 --> 00:29:14,760
description of this video

676
00:29:14,760 --> 00:29:16,980
once you're on this page use the links

677
00:29:16,980 --> 00:29:19,110
given there to access the labs

678
00:29:19,110 --> 00:29:22,769
associated to your lecture each lecture

679
00:29:22,769 --> 00:29:26,010
has its own lab so remember to choose

680
00:29:26,010 --> 00:29:28,110
the right lab for your lecture

681
00:29:28,110 --> 00:29:31,139
the labs open up right in your browser I

682
00:29:31,139 --> 00:29:33,659
would recommend to use google chrome

683
00:29:33,659 --> 00:29:36,360
while working with the labs the

684
00:29:36,360 --> 00:29:38,429
interface consists of two parts a

685
00:29:38,429 --> 00:29:40,889
terminal on the left and a quiz portal

686
00:29:40,889 --> 00:29:43,230
on the right the cooze portal on the

687
00:29:43,230 --> 00:29:45,090
right gives you challenges to solve

688
00:29:45,090 --> 00:29:47,250
follow the quiz and try and answer the

689
00:29:47,250 --> 00:29:49,409
questions asked and complete the tasks

690
00:29:49,409 --> 00:29:52,230
given to you each scenario consists of

691
00:29:52,230 --> 00:29:54,600
anywhere from 10 to 20 questions that

692
00:29:54,600 --> 00:29:56,580
needs to be answered within 30 minutes

693
00:29:56,580 --> 00:29:59,519
to an hour at the top you have the

694
00:29:59,519 --> 00:30:01,500
question numbers below that is the

695
00:30:01,500 --> 00:30:03,690
remaining time for your lab below that

696
00:30:03,690 --> 00:30:04,590
is the question

697
00:30:04,590 --> 00:30:06,419
if you're not able to solve the

698
00:30:06,419 --> 00:30:08,789
challenge look for hints in the hints

699
00:30:08,789 --> 00:30:10,950
section you may skip a question by

700
00:30:10,950 --> 00:30:12,870
hitting the skip button in the top right

701
00:30:12,870 --> 00:30:15,539
corner but remember that you will not be

702
00:30:15,539 --> 00:30:18,059
able to go back to a previous question

703
00:30:18,059 --> 00:30:20,970
once you have skipped if the quiz portal

704
00:30:20,970 --> 00:30:23,460
gets stuck for some reason click on the

705
00:30:23,460 --> 00:30:26,700
quiz portal tab at the top to open the

706
00:30:26,700 --> 00:30:33,299
quiz portal in a separate window the

707
00:30:33,299 --> 00:30:35,490
terminal gives you access to a real

708
00:30:35,490 --> 00:30:38,220
system running Tucker you can run any

709
00:30:38,220 --> 00:30:39,899
docker command here and run your own

710
00:30:39,899 --> 00:30:42,659
containers or applications you would

711
00:30:42,659 --> 00:30:44,460
typically be running commands to solve

712
00:30:44,460 --> 00:30:46,710
the tasks assigned in the quiz portal

713
00:30:46,710 --> 00:30:49,049
you may play around and experiment with

714
00:30:49,049 --> 00:30:51,120
this environment but make sure you do

715
00:30:51,120 --> 00:30:52,919
that after you've gone through the quiz

716
00:30:52,919 --> 00:30:55,230
so that your work does not interfere

717
00:30:55,230 --> 00:30:58,950
with the tasks provided by the quiz so

718
00:30:58,950 --> 00:31:00,799
let me walk you through a few questions

719
00:31:00,799 --> 00:31:03,870
there are two types of questions each

720
00:31:03,870 --> 00:31:06,800
lab scenario starts with a set of export

721
00:31:06,800 --> 00:31:09,350
multiple-choice questions where you're

722
00:31:09,350 --> 00:31:11,660
asked to explore and find information in

723
00:31:11,660 --> 00:31:13,610
the given environment and select the

724
00:31:13,610 --> 00:31:16,160
right answer this is to get you

725
00:31:16,160 --> 00:31:18,440
familiarized with a set up you are then

726
00:31:18,440 --> 00:31:20,270
asked to perform tasks like run a

727
00:31:20,270 --> 00:31:23,270
container stop them delete them build

728
00:31:23,270 --> 00:31:27,020
your own image etc here the first

729
00:31:27,020 --> 00:31:29,030
question asks us to find the version of

730
00:31:29,030 --> 00:31:31,180
docker server engine running on the host

731
00:31:31,180 --> 00:31:33,890
run the docker reversion command in the

732
00:31:33,890 --> 00:31:36,130
terminal and identify the right version

733
00:31:36,130 --> 00:31:38,660
then select the appropriate option from

734
00:31:38,660 --> 00:31:43,070
the given choices another example is the

735
00:31:43,070 --> 00:31:45,830
fourth question where it asks you to run

736
00:31:45,830 --> 00:31:49,730
a container using the Redis image if

737
00:31:49,730 --> 00:31:52,010
you're not sure of the command click on

738
00:31:52,010 --> 00:31:55,370
hints and it will show you a hint we now

739
00:31:55,370 --> 00:31:57,410
run a Redis container using the docker

740
00:31:57,410 --> 00:31:59,540
run readies command wait for the

741
00:31:59,540 --> 00:32:02,060
container to run once done click on

742
00:32:02,060 --> 00:32:05,240
check to check your work we have now

743
00:32:05,240 --> 00:32:07,040
successfully completed the task

744
00:32:07,040 --> 00:32:09,380
similarly follow along and complete all

745
00:32:09,380 --> 00:32:12,250
tasks once the lab exercise is completed

746
00:32:12,250 --> 00:32:14,570
remember to leave a feedback and let us

747
00:32:14,570 --> 00:32:16,630
know how it went a few things to note

748
00:32:16,630 --> 00:32:19,850
these are publicly accessible labs that

749
00:32:19,850 --> 00:32:22,220
anyone can access so if you catch

750
00:32:22,220 --> 00:32:25,000
yourself logged out during a peak hour

751
00:32:25,000 --> 00:32:28,300
please wait for some time and try again

752
00:32:28,300 --> 00:32:31,580
also remember to not store any private

753
00:32:31,580 --> 00:32:34,090
or confidential data on these systems

754
00:32:34,090 --> 00:32:37,250
remember that this environment is for

755
00:32:37,250 --> 00:32:39,620
learning purposes only and is only alive

756
00:32:39,620 --> 00:32:42,020
for an hour after which the lab is

757
00:32:42,020 --> 00:32:45,860
destroyed so does all your work but you

758
00:32:45,860 --> 00:32:48,200
may start over and access these labs as

759
00:32:48,200 --> 00:32:50,510
many times as you want until you feel

760
00:32:50,510 --> 00:32:53,510
confident I will also post solutions to

761
00:32:53,510 --> 00:32:55,730
these lab quizzes so if you run into

762
00:32:55,730 --> 00:32:58,460
issues you may refer to those that's it

763
00:32:58,460 --> 00:33:00,140
for now header words are the first

764
00:33:00,140 --> 00:33:02,480
challenge and I will see you on the

765
00:33:02,480 --> 00:33:04,930
other side

766
00:33:05,100 --> 00:33:08,700
[Music]

767
00:33:08,700 --> 00:33:11,290
we will now look at some of the other

768
00:33:11,290 --> 00:33:14,050
docker run commands at the end of this

769
00:33:14,050 --> 00:33:15,640
lecture you will go through a hands-on

770
00:33:15,640 --> 00:33:17,080
quiz where you will practice working

771
00:33:17,080 --> 00:33:20,320
with these commands we learned that we

772
00:33:20,320 --> 00:33:23,170
could use the docker run Redis command

773
00:33:23,170 --> 00:33:24,940
to run the container running a Redis

774
00:33:24,940 --> 00:33:27,460
service in this case the latest version

775
00:33:27,460 --> 00:33:30,880
of Redis which happens to be 5.0 to 5 as

776
00:33:30,880 --> 00:33:33,640
of today but what if we want to run

777
00:33:33,640 --> 00:33:35,890
another version of Redis like for

778
00:33:35,890 --> 00:33:39,610
example and older versions say 4.0 then

779
00:33:39,610 --> 00:33:42,010
you specify the version separated by a

780
00:33:42,010 --> 00:33:47,050
colon this is called a tag in that case

781
00:33:47,050 --> 00:33:50,200
docker pulls an image of the 4.0 version

782
00:33:50,200 --> 00:33:54,790
of Redis and runs that also notice that

783
00:33:54,790 --> 00:33:57,670
if you don't specify any tag as in the

784
00:33:57,670 --> 00:34:00,130
first command docker will consider the

785
00:34:00,130 --> 00:34:04,300
default tag to be latest latest is a tag

786
00:34:04,300 --> 00:34:06,730
associated to the latest version of that

787
00:34:06,730 --> 00:34:08,830
software which is governed by the

788
00:34:08,830 --> 00:34:12,460
authors of that software so as a user

789
00:34:12,460 --> 00:34:15,219
how do you find information about these

790
00:34:15,219 --> 00:34:18,270
versions and what is the latest at

791
00:34:18,270 --> 00:34:22,420
docker hub com look up an image and you

792
00:34:22,420 --> 00:34:25,000
will find all the supported tags in its

793
00:34:25,000 --> 00:34:27,489
description each version of the software

794
00:34:27,489 --> 00:34:30,250
can have multiple short and long tags

795
00:34:30,250 --> 00:34:34,360
associated with it as seen here in this

796
00:34:34,360 --> 00:34:37,810
case the version fight of 0.5 also has

797
00:34:37,810 --> 00:34:40,500
the latest tag on it

798
00:34:40,500 --> 00:34:44,650
let's now look at inputs I have a simple

799
00:34:44,650 --> 00:34:47,560
prompt application that when run asks

800
00:34:47,560 --> 00:34:50,260
for my name and on entering my name

801
00:34:50,260 --> 00:34:53,679
prints a welcome message if I were to

802
00:34:53,679 --> 00:34:55,690
docker eyes this application and run it

803
00:34:55,690 --> 00:34:58,300
as a docker container like this it

804
00:34:58,300 --> 00:35:00,880
wouldn't wait for the prompt it just

805
00:35:00,880 --> 00:35:02,650
prints whatever the application is

806
00:35:02,650 --> 00:35:06,160
supposed to print on standard out that

807
00:35:06,160 --> 00:35:08,380
is because by default the docker

808
00:35:08,380 --> 00:35:10,990
container does not listen to a standard

809
00:35:10,990 --> 00:35:13,600
input even though you are attached to

810
00:35:13,600 --> 00:35:16,540
its console it is not able to read any

811
00:35:16,540 --> 00:35:18,760
input from you it doesn't have a

812
00:35:18,760 --> 00:35:20,110
terminal to read in

813
00:35:20,110 --> 00:35:22,810
what's from it runs in a non-interactive

814
00:35:22,810 --> 00:35:25,780
mud if you would like to provide your

815
00:35:25,780 --> 00:35:26,440
input

816
00:35:26,440 --> 00:35:29,590
you must map the standard input of your

817
00:35:29,590 --> 00:35:32,230
host to the docker container using the -

818
00:35:32,230 --> 00:35:34,960
I parameter the - I parameter is for

819
00:35:34,960 --> 00:35:37,600
interactive mode and when I input my

820
00:35:37,600 --> 00:35:41,470
name it prints the expected output but

821
00:35:41,470 --> 00:35:42,970
there is something still missing from

822
00:35:42,970 --> 00:35:48,280
this the prompt when we run the app at

823
00:35:48,280 --> 00:35:51,940
first it asked us for our name but when

824
00:35:51,940 --> 00:35:54,340
docker iced that prompt is missing

825
00:35:54,340 --> 00:35:56,650
even though it seems to have accepted my

826
00:35:56,650 --> 00:35:59,800
input that is because the application

827
00:35:59,800 --> 00:36:02,740
prompt on the terminal and we have not

828
00:36:02,740 --> 00:36:06,430
attached to the containers terminal for

829
00:36:06,430 --> 00:36:10,120
this use the - T option as well the - T

830
00:36:10,120 --> 00:36:14,650
stands for a sudo terminal so with the

831
00:36:14,650 --> 00:36:17,830
combination of - int we are now attached

832
00:36:17,830 --> 00:36:19,900
to the terminal as well as in an

833
00:36:19,900 --> 00:36:23,080
interactive mode on the container we

834
00:36:23,080 --> 00:36:25,450
will now look at port mapping or port

835
00:36:25,450 --> 00:36:28,240
publishing on containers let's go back

836
00:36:28,240 --> 00:36:30,400
to the example where we run a simple web

837
00:36:30,400 --> 00:36:32,560
application in a docker container on my

838
00:36:32,560 --> 00:36:35,590
docker host remember the underlying host

839
00:36:35,590 --> 00:36:37,750
where docker is installed is called

840
00:36:37,750 --> 00:36:41,050
docker host or docker engine when we run

841
00:36:41,050 --> 00:36:43,390
a containerized web application it runs

842
00:36:43,390 --> 00:36:45,550
and we are able to see that the server

843
00:36:45,550 --> 00:36:48,670
is running but how does a user access my

844
00:36:48,670 --> 00:36:51,520
application as you can see my

845
00:36:51,520 --> 00:36:54,490
application is listening on port 5,000

846
00:36:54,490 --> 00:36:57,070
so I could access my application by

847
00:36:57,070 --> 00:37:01,030
using port 5000 but what IP do I use to

848
00:37:01,030 --> 00:37:04,240
access it from a web browser there are

849
00:37:04,240 --> 00:37:06,760
two options available one is to use the

850
00:37:06,760 --> 00:37:09,490
IP of the docker container every docker

851
00:37:09,490 --> 00:37:11,860
container gets an IP assigned by default

852
00:37:11,860 --> 00:37:16,630
in this case it is 172 dot 17.0 - but

853
00:37:16,630 --> 00:37:19,420
remember that this is an internal IP and

854
00:37:19,420 --> 00:37:21,580
is only accessible within the docker

855
00:37:21,580 --> 00:37:24,340
host so if you open a browser from

856
00:37:24,340 --> 00:37:26,730
within the docker host you can go to

857
00:37:26,730 --> 00:37:30,570
http colon forward slash forward slash

858
00:37:30,570 --> 00:37:33,940
172 dot 17 dot 0 dot 1

859
00:37:33,940 --> 00:37:39,260
: 5,000 to access the IP address but

860
00:37:39,260 --> 00:37:41,930
since this is an internal IP users

861
00:37:41,930 --> 00:37:44,240
outside of the docker host cannot access

862
00:37:44,240 --> 00:37:47,690
it using this IP for this we could use

863
00:37:47,690 --> 00:37:50,120
the IP of the docker host which is one

864
00:37:50,120 --> 00:37:52,600
ninety two dot one sixty eight dot 1.5

865
00:37:52,600 --> 00:37:55,670
but for that to work you must have

866
00:37:55,670 --> 00:37:57,860
mapped the port inside the docker

867
00:37:57,860 --> 00:38:00,680
container to a free port on the docker

868
00:38:00,680 --> 00:38:03,650
host for example if I want the users to

869
00:38:03,650 --> 00:38:06,200
access my application through port 80 on

870
00:38:06,200 --> 00:38:09,320
my docker host I could map port 80 of

871
00:38:09,320 --> 00:38:12,590
local host to port 5000 on the docker

872
00:38:12,590 --> 00:38:15,680
container using the dash P parameter in

873
00:38:15,680 --> 00:38:20,360
my run command like this and so the user

874
00:38:20,360 --> 00:38:22,700
can access my application by going to

875
00:38:22,700 --> 00:38:26,630
the URL HTTP colon slash slash one

876
00:38:26,630 --> 00:38:28,610
ninety two dot one sixty eight dot one

877
00:38:28,610 --> 00:38:33,110
dot five colon 80 and all traffic on

878
00:38:33,110 --> 00:38:35,720
port 80 on my daugher host will get

879
00:38:35,720 --> 00:38:38,390
routed to port 5000 inside the docker

880
00:38:38,390 --> 00:38:42,290
container this way you can run multiple

881
00:38:42,290 --> 00:38:44,810
instances of your application and map

882
00:38:44,810 --> 00:38:46,640
them to different ports on the docker

883
00:38:46,640 --> 00:38:49,880
host or run instances of different

884
00:38:49,880 --> 00:38:52,250
applications on different ports for

885
00:38:52,250 --> 00:38:54,080
example in this case and running an

886
00:38:54,080 --> 00:38:56,810
instance of MySQL that runs a database

887
00:38:56,810 --> 00:38:59,210
on my host and listens on the default

888
00:38:59,210 --> 00:39:01,700
MySQL port which happens to be three

889
00:39:01,700 --> 00:39:02,630
3:06

890
00:39:02,630 --> 00:39:05,780
or another instance of MySQL on another

891
00:39:05,780 --> 00:39:09,430
port eight 3:06 so you can run as many

892
00:39:09,430 --> 00:39:12,050
applications like this and map them to

893
00:39:12,050 --> 00:39:14,900
as many ports as you want and of course

894
00:39:14,900 --> 00:39:17,180
you cannot map to the same port on the

895
00:39:17,180 --> 00:39:21,110
docker host more than once we will

896
00:39:21,110 --> 00:39:23,000
discuss more about port mapping and

897
00:39:23,000 --> 00:39:24,920
networking of containers in the network

898
00:39:24,920 --> 00:39:27,710
lecture later on let's now look at how

899
00:39:27,710 --> 00:39:31,300
data is persisted in a docker container

900
00:39:31,300 --> 00:39:34,160
for example let's say you were to run a

901
00:39:34,160 --> 00:39:36,950
MySQL container when databases and

902
00:39:36,950 --> 00:39:39,410
tables are created the data files are

903
00:39:39,410 --> 00:39:43,490
stored in location /wor Labe MySQL

904
00:39:43,490 --> 00:39:46,329
inside the docker container remember

905
00:39:46,329 --> 00:39:47,949
the docker container has its own

906
00:39:47,949 --> 00:39:50,859
isolated filesystem and any changes to

907
00:39:50,859 --> 00:39:53,969
any files happen within the container

908
00:39:53,969 --> 00:39:57,189
let's assume you dump a lot of data into

909
00:39:57,189 --> 00:39:59,829
the database what happens if you were to

910
00:39:59,829 --> 00:40:02,410
delete the MySQL container and remove it

911
00:40:02,410 --> 00:40:05,709
as soon as you do that the container

912
00:40:05,709 --> 00:40:08,319
along with all the data inside it gets

913
00:40:08,319 --> 00:40:09,219
blown away

914
00:40:09,219 --> 00:40:12,969
meaning all your data is gone if you

915
00:40:12,969 --> 00:40:15,279
would like to persist data you would

916
00:40:15,279 --> 00:40:17,650
want to map a directory outside the

917
00:40:17,650 --> 00:40:19,749
container on the docker host to a

918
00:40:19,749 --> 00:40:22,359
directory inside the container in this

919
00:40:22,359 --> 00:40:25,599
case I create a directory called /opt

920
00:40:25,599 --> 00:40:30,849
slash data dir and map that to var Lib

921
00:40:30,849 --> 00:40:34,209
MySQL inside the docker container using

922
00:40:34,209 --> 00:40:36,759
the - V option and specifying the

923
00:40:36,759 --> 00:40:38,890
directory on the docker host followed by

924
00:40:38,890 --> 00:40:41,439
a colon and the directory inside the

925
00:40:41,439 --> 00:40:42,719
gawker container

926
00:40:42,719 --> 00:40:45,910
this way when docker container runs it

927
00:40:45,910 --> 00:40:48,579
will implicitly mount the external

928
00:40:48,579 --> 00:40:51,279
directory to a folder inside the docker

929
00:40:51,279 --> 00:40:54,160
container this way all your data will

930
00:40:54,160 --> 00:40:56,999
now be stored in the external volume at

931
00:40:56,999 --> 00:41:00,910
/opt slash data directory and thus will

932
00:41:00,910 --> 00:41:03,130
remain even if you delete the docker

933
00:41:03,130 --> 00:41:06,969
container the docker PS command is good

934
00:41:06,969 --> 00:41:08,589
enough to get basic details about

935
00:41:08,589 --> 00:41:11,859
containers like their names and ID's but

936
00:41:11,859 --> 00:41:13,719
if you would like to see additional

937
00:41:13,719 --> 00:41:16,329
details about a specific container use

938
00:41:16,329 --> 00:41:16,869
the docker

939
00:41:16,869 --> 00:41:18,640
inspect command and provide the

940
00:41:18,640 --> 00:41:21,819
container name or ID it returns all

941
00:41:21,819 --> 00:41:23,979
details of a container in a taste on

942
00:41:23,979 --> 00:41:26,619
format such as the state Mounds

943
00:41:26,619 --> 00:41:29,499
configuration data network settings etc

944
00:41:29,499 --> 00:41:32,140
remember to use it when you're required

945
00:41:32,140 --> 00:41:34,499
to find details on a container and

946
00:41:34,499 --> 00:41:37,420
finally how do we see the logs of a

947
00:41:37,420 --> 00:41:39,729
container we ran in the background for

948
00:41:39,729 --> 00:41:41,890
example I ran my simple web application

949
00:41:41,890 --> 00:41:44,709
using the - D parameter and it ran the

950
00:41:44,709 --> 00:41:47,890
container in a detached mode how do I

951
00:41:47,890 --> 00:41:49,929
view the logs which happens to be the

952
00:41:49,929 --> 00:41:51,910
contents written to the standard out of

953
00:41:51,910 --> 00:41:55,209
that container use the docker logs

954
00:41:55,209 --> 00:41:57,609
command and specify the container ID or

955
00:41:57,609 --> 00:42:00,040
name like this

956
00:42:00,040 --> 00:42:03,040
well a sit for this lecture head over to

957
00:42:03,040 --> 00:42:04,990
the challenges and practice working with

958
00:42:04,990 --> 00:42:12,520
docker commands so to start with a

959
00:42:12,520 --> 00:42:15,130
simple web application written in Python

960
00:42:15,130 --> 00:42:17,770
this piece of code is used to create a

961
00:42:17,770 --> 00:42:20,140
web application that displays a web page

962
00:42:20,140 --> 00:42:22,600
with a background color if you look

963
00:42:22,600 --> 00:42:25,060
closely into the application code you

964
00:42:25,060 --> 00:42:27,070
will see a line that sets the background

965
00:42:27,070 --> 00:42:30,130
color to red now that works just fine

966
00:42:30,130 --> 00:42:32,680
however if you decide to change the

967
00:42:32,680 --> 00:42:34,780
color in the future you will have to

968
00:42:34,780 --> 00:42:37,660
change the application code it is a best

969
00:42:37,660 --> 00:42:40,270
practice to move such information out of

970
00:42:40,270 --> 00:42:42,970
the application code and into say an

971
00:42:42,970 --> 00:42:45,600
environment variable called app color

972
00:42:45,600 --> 00:42:47,710
the next time you run the application

973
00:42:47,710 --> 00:42:50,410
set an environment variable called app

974
00:42:50,410 --> 00:42:52,990
color to a desired value and the

975
00:42:52,990 --> 00:42:56,230
application now has a new color once

976
00:42:56,230 --> 00:42:58,000
your application gets packaged into a

977
00:42:58,000 --> 00:43:00,910
docker image he would then run it with

978
00:43:00,910 --> 00:43:02,860
the docker run command followed by the

979
00:43:02,860 --> 00:43:06,130
name of the image however if you wish to

980
00:43:06,130 --> 00:43:08,290
pass the environment variable as we did

981
00:43:08,290 --> 00:43:11,080
before he would now use the docker run

982
00:43:11,080 --> 00:43:13,960
commands - II option to set an

983
00:43:13,960 --> 00:43:15,910
environment variable within the

984
00:43:15,910 --> 00:43:18,580
container to deploy multiple containers

985
00:43:18,580 --> 00:43:20,950
with different colors he would run the

986
00:43:20,950 --> 00:43:23,590
docker command multiple times and set a

987
00:43:23,590 --> 00:43:25,390
different value for the environment

988
00:43:25,390 --> 00:43:29,080
variable each time so how do you find

989
00:43:29,080 --> 00:43:31,240
the environment variable set on a

990
00:43:31,240 --> 00:43:34,780
container that's already running use the

991
00:43:34,780 --> 00:43:37,360
docker inspect command to inspect the

992
00:43:37,360 --> 00:43:39,880
properties of a running container under

993
00:43:39,880 --> 00:43:42,070
the config section you will find the

994
00:43:42,070 --> 00:43:44,470
list of environment variables set on the

995
00:43:44,470 --> 00:43:46,480
container well that's it for this

996
00:43:46,480 --> 00:43:48,730
lecture on configuring environment

997
00:43:48,730 --> 00:43:51,810
variables in docker

998
00:43:55,560 --> 00:44:04,210
[Music]

999
00:44:04,210 --> 00:44:06,770
hello and welcome to this lecture on

1000
00:44:06,770 --> 00:44:10,310
docker images in this lecture we're

1001
00:44:10,310 --> 00:44:12,410
going to see how to create your own

1002
00:44:12,410 --> 00:44:16,340
image now before that why would you need

1003
00:44:16,340 --> 00:44:18,890
to create your own image it could either

1004
00:44:18,890 --> 00:44:21,620
be because you cannot find a component

1005
00:44:21,620 --> 00:44:23,930
or a service that you want to use as

1006
00:44:23,930 --> 00:44:26,150
part of your application on docker hub

1007
00:44:26,150 --> 00:44:29,030
already or you and your team decided

1008
00:44:29,030 --> 00:44:30,530
that the application you're developing

1009
00:44:30,530 --> 00:44:33,860
will be derived for ease of shipping and

1010
00:44:33,860 --> 00:44:37,280
deployment in this case I'm going to

1011
00:44:37,280 --> 00:44:40,670
containerize an application a simple web

1012
00:44:40,670 --> 00:44:43,370
application that I have built using the

1013
00:44:43,370 --> 00:44:47,360
Python flask framework first we need to

1014
00:44:47,360 --> 00:44:49,670
understand what we our container izing

1015
00:44:49,670 --> 00:44:52,070
or what application we are creating an

1016
00:44:52,070 --> 00:44:54,440
image for and how the application is

1017
00:44:54,440 --> 00:44:57,080
built so start by thinking what you

1018
00:44:57,080 --> 00:44:58,820
might do if you want to deploy the

1019
00:44:58,820 --> 00:45:01,460
application manually we write down the

1020
00:45:01,460 --> 00:45:03,640
steps required in the right order and

1021
00:45:03,640 --> 00:45:06,320
creating an image for a simple web

1022
00:45:06,320 --> 00:45:08,720
application if I were to set it up

1023
00:45:08,720 --> 00:45:11,300
manually I would start with an operating

1024
00:45:11,300 --> 00:45:14,540
system like Ubuntu then update the

1025
00:45:14,540 --> 00:45:16,910
source repositories using the apt

1026
00:45:16,910 --> 00:45:19,520
command then install dependencies using

1027
00:45:19,520 --> 00:45:22,250
the apt command then install Python

1028
00:45:22,250 --> 00:45:25,100
dependencies using the PIP command then

1029
00:45:25,100 --> 00:45:26,840
copy over the source code of my

1030
00:45:26,840 --> 00:45:30,080
application to a location like opt and

1031
00:45:30,080 --> 00:45:32,900
then finally run the web server using

1032
00:45:32,900 --> 00:45:35,750
the flask command now that I have the

1033
00:45:35,750 --> 00:45:38,420
instructions create a docker file using

1034
00:45:38,420 --> 00:45:40,850
this here's a quick overview of the

1035
00:45:40,850 --> 00:45:44,030
process of creating your own image first

1036
00:45:44,030 --> 00:45:47,060
create a docker file named docker file

1037
00:45:47,060 --> 00:45:49,220
and write down the instructions for

1038
00:45:49,220 --> 00:45:52,280
setting up your application in it such

1039
00:45:52,280 --> 00:45:54,830
as installing dependencies where to copy

1040
00:45:54,830 --> 00:45:57,680
the source code from and to and what the

1041
00:45:57,680 --> 00:46:00,010
entry point of the application is etc

1042
00:46:00,010 --> 00:46:03,500
once done build your image using the

1043
00:46:03,500 --> 00:46:05,540
docker build command and specify the

1044
00:46:05,540 --> 00:46:08,480
docker file as input as well as a tag

1045
00:46:08,480 --> 00:46:08,869
name

1046
00:46:08,869 --> 00:46:11,809
for the image this will create an image

1047
00:46:11,809 --> 00:46:14,839
locally on your system to make it

1048
00:46:14,839 --> 00:46:16,819
available on the public docker hub

1049
00:46:16,819 --> 00:46:20,710
registry run the docker push command and

1050
00:46:20,710 --> 00:46:23,089
specify the name of the image you just

1051
00:46:23,089 --> 00:46:27,019
created in this case the name of the

1052
00:46:27,019 --> 00:46:30,079
image is my account name which is M

1053
00:46:30,079 --> 00:46:33,769
Amjad followed by the image name which

1054
00:46:33,769 --> 00:46:38,359
is my custom app now let's take a closer

1055
00:46:38,359 --> 00:46:41,390
look at that docker file docker file is

1056
00:46:41,390 --> 00:46:43,819
a text file written in a specific format

1057
00:46:43,819 --> 00:46:46,369
that docker can understand it's in an

1058
00:46:46,369 --> 00:46:49,819
instruction and arguments format for

1059
00:46:49,819 --> 00:46:52,400
example in this docker file everything

1060
00:46:52,400 --> 00:46:56,029
on the left in caps is an instruction in

1061
00:46:56,029 --> 00:46:59,839
this case from run copy and entry point

1062
00:46:59,839 --> 00:47:02,930
are all instructions each of these

1063
00:47:02,930 --> 00:47:05,480
instruct docker to perform a specific

1064
00:47:05,480 --> 00:47:07,599
action while creating the image

1065
00:47:07,599 --> 00:47:10,279
everything on the right is an argument

1066
00:47:10,279 --> 00:47:13,579
to those instructions the first line

1067
00:47:13,579 --> 00:47:16,999
from Ubuntu defines what the base OS

1068
00:47:16,999 --> 00:47:19,579
should be for this container every

1069
00:47:19,579 --> 00:47:21,950
docker image must be based off of

1070
00:47:21,950 --> 00:47:25,369
another image either an OS or another

1071
00:47:25,369 --> 00:47:27,799
image that was created before based on

1072
00:47:27,799 --> 00:47:30,859
an OS you can find official releases of

1073
00:47:30,859 --> 00:47:33,859
all operating systems on docker hub it's

1074
00:47:33,859 --> 00:47:36,289
important to note that all docker files

1075
00:47:36,289 --> 00:47:39,680
must start with a from instruction the

1076
00:47:39,680 --> 00:47:42,349
run instruction instructs docker to run

1077
00:47:42,349 --> 00:47:44,779
a particular command on those base

1078
00:47:44,779 --> 00:47:47,989
images so at this point docker runs the

1079
00:47:47,989 --> 00:47:50,749
apt-get update commands to fetch the

1080
00:47:50,749 --> 00:47:53,660
updated packages and installs required

1081
00:47:53,660 --> 00:47:56,960
dependencies on the image then the copy

1082
00:47:56,960 --> 00:47:59,299
instruction copies files from the local

1083
00:47:59,299 --> 00:48:02,029
system onto the docker image in this

1084
00:48:02,029 --> 00:48:04,009
case the source code of our application

1085
00:48:04,009 --> 00:48:06,259
is in the current folder and I will be

1086
00:48:06,259 --> 00:48:08,900
copying it over to the location opt

1087
00:48:08,900 --> 00:48:11,529
source code inside the docker image and

1088
00:48:11,529 --> 00:48:14,989
finally entry point allows us to specify

1089
00:48:14,989 --> 00:48:17,749
a command that will be run when the

1090
00:48:17,749 --> 00:48:21,579
image is run as a container

1091
00:48:22,090 --> 00:48:24,460
when docker builds the images it builds

1092
00:48:24,460 --> 00:48:26,890
these in a layered architecture each

1093
00:48:26,890 --> 00:48:29,080
line of instruction creates a new layer

1094
00:48:29,080 --> 00:48:31,540
in the docker image with just the

1095
00:48:31,540 --> 00:48:34,000
changes from the previous layer for

1096
00:48:34,000 --> 00:48:36,790
example the first layer is a base Ubuntu

1097
00:48:36,790 --> 00:48:40,840
OS followed by the second instruction

1098
00:48:40,840 --> 00:48:42,940
that creates a second layer which

1099
00:48:42,940 --> 00:48:45,640
installs all the apt packages and then

1100
00:48:45,640 --> 00:48:47,320
the third instruction creates a third

1101
00:48:47,320 --> 00:48:49,480
layer with the Python packages followed

1102
00:48:49,480 --> 00:48:51,490
by the fourth layer that copies the

1103
00:48:51,490 --> 00:48:53,800
source code over and the final layer

1104
00:48:53,800 --> 00:48:55,660
that updates the entry point of the

1105
00:48:55,660 --> 00:48:59,110
image since each layer only stores the

1106
00:48:59,110 --> 00:49:01,390
changes from the previous layer it is

1107
00:49:01,390 --> 00:49:04,090
reflected in the size as well if you

1108
00:49:04,090 --> 00:49:06,760
look at the base opened to image it is

1109
00:49:06,760 --> 00:49:10,810
around 120 MB in size the apt packages

1110
00:49:10,810 --> 00:49:13,780
that I install is around 300 MB and the

1111
00:49:13,780 --> 00:49:16,450
remaining layers are small you could see

1112
00:49:16,450 --> 00:49:18,310
this information if you run the docker

1113
00:49:18,310 --> 00:49:20,890
history command followed by the image

1114
00:49:20,890 --> 00:49:27,800
name when you run the door

1115
00:49:27,800 --> 00:49:29,660
Bilka man you could see the various

1116
00:49:29,660 --> 00:49:31,640
steps involved and the result of each

1117
00:49:31,640 --> 00:49:34,790
task all the layers built are cast

1118
00:49:34,790 --> 00:49:36,830
so the layered architecture helps you

1119
00:49:36,830 --> 00:49:39,050
restart docker built from that

1120
00:49:39,050 --> 00:49:41,870
particular step in case it fails or if

1121
00:49:41,870 --> 00:49:43,790
you were to add new steps in the build

1122
00:49:43,790 --> 00:49:46,100
process you wouldn't have to start all

1123
00:49:46,100 --> 00:49:53,150
over again all the layers built are

1124
00:49:53,150 --> 00:49:56,120
cached by docker so in case a particular

1125
00:49:56,120 --> 00:49:59,090
step was to fail for example in this

1126
00:49:59,090 --> 00:50:02,210
case step three failed and you were to

1127
00:50:02,210 --> 00:50:05,600
fix the issue and rerun docker build it

1128
00:50:05,600 --> 00:50:07,730
will reuse the previous layers from

1129
00:50:07,730 --> 00:50:10,070
cache and continue to build the

1130
00:50:10,070 --> 00:50:13,250
remaining layers the same is true if you

1131
00:50:13,250 --> 00:50:15,500
were to add additional steps in the

1132
00:50:15,500 --> 00:50:18,590
docker file this way rebuilding your

1133
00:50:18,590 --> 00:50:21,680
image is faster and you don't have to

1134
00:50:21,680 --> 00:50:23,990
wait for docker to rebuild the entire

1135
00:50:23,990 --> 00:50:26,960
image each time this is helpful

1136
00:50:26,960 --> 00:50:29,060
especially when you update source code

1137
00:50:29,060 --> 00:50:31,310
of your application as it may change

1138
00:50:31,310 --> 00:50:34,280
more frequently only the layers above

1139
00:50:34,280 --> 00:50:38,620
the updated layers needs to be rebuilt

1140
00:50:41,020 --> 00:50:43,910
we just saw a number of products

1141
00:50:43,910 --> 00:50:47,140
containerized such as databases

1142
00:50:47,140 --> 00:50:50,360
development tools operating systems etc

1143
00:50:50,360 --> 00:50:53,120
but that's just not it you can

1144
00:50:53,120 --> 00:50:55,130
containerized almost all of the

1145
00:50:55,130 --> 00:50:57,260
application even simple ones like

1146
00:50:57,260 --> 00:51:00,070
browsers or utilities like curl

1147
00:51:00,070 --> 00:51:03,470
applications like Spotify Skype etc

1148
00:51:03,470 --> 00:51:05,720
basically you can containerize

1149
00:51:05,720 --> 00:51:08,780
everything and going forward and see

1150
00:51:08,780 --> 00:51:10,550
that's how everyone is going to run

1151
00:51:10,550 --> 00:51:13,670
applications nobody is going to install

1152
00:51:13,670 --> 00:51:16,430
anything anymore going forward instead

1153
00:51:16,430 --> 00:51:19,430
they're just going to run it using

1154
00:51:19,430 --> 00:51:21,560
docker and when they don't need it

1155
00:51:21,560 --> 00:51:22,010
anymore

1156
00:51:22,010 --> 00:51:24,590
get rid of it easily without having to

1157
00:51:24,590 --> 00:51:26,740
clean up too much

1158
00:51:26,740 --> 00:51:30,370
[Music]

1159
00:51:30,370 --> 00:51:34,490
in this lecture we will look at commands

1160
00:51:34,490 --> 00:51:37,120
arguments and entry points in docker

1161
00:51:37,120 --> 00:51:40,430
let's start with a simple scenario say

1162
00:51:40,430 --> 00:51:42,350
you were to run a docker container from

1163
00:51:42,350 --> 00:51:44,900
an Ubuntu image when you run the docker

1164
00:51:44,900 --> 00:51:47,720
run Ubuntu command it runs an instance

1165
00:51:47,720 --> 00:51:51,200
of Ubuntu image and exits immediately if

1166
00:51:51,200 --> 00:51:53,000
you were to list the running containers

1167
00:51:53,000 --> 00:51:55,310
you wouldn't see the container running

1168
00:51:55,310 --> 00:51:57,890
if you list all containers including

1169
00:51:57,890 --> 00:52:00,260
those that are stopped you will see that

1170
00:52:00,260 --> 00:52:01,370
the new container

1171
00:52:01,370 --> 00:52:04,910
you ran is in an excited state now why

1172
00:52:04,910 --> 00:52:08,060
is that unlike virtual machines

1173
00:52:08,060 --> 00:52:10,580
containers are not meant to host an

1174
00:52:10,580 --> 00:52:13,160
operating system containers are meant to

1175
00:52:13,160 --> 00:52:16,580
run a specific task or process such as

1176
00:52:16,580 --> 00:52:19,010
to host an instance of a web server or

1177
00:52:19,010 --> 00:52:21,500
application server or a database or

1178
00:52:21,500 --> 00:52:23,330
simply to carry out some kind of

1179
00:52:23,330 --> 00:52:27,140
computation or analysis once the task is

1180
00:52:27,140 --> 00:52:27,860
complete

1181
00:52:27,860 --> 00:52:30,950
the container exits a container only

1182
00:52:30,950 --> 00:52:33,620
lives as long as the process inside it

1183
00:52:33,620 --> 00:52:37,340
is alive if the web service inside the

1184
00:52:37,340 --> 00:52:39,950
container is dot or crashes the

1185
00:52:39,950 --> 00:52:42,470
container exits so who defines what

1186
00:52:42,470 --> 00:52:45,470
process is run within the container if

1187
00:52:45,470 --> 00:52:47,660
you look at the docker file for popular

1188
00:52:47,660 --> 00:52:50,000
docker images like ng INX

1189
00:52:50,000 --> 00:52:52,670
you will see an instruction called CMD

1190
00:52:52,670 --> 00:52:54,980
which stands for command that defines

1191
00:52:54,980 --> 00:52:57,110
the program that will be run within the

1192
00:52:57,110 --> 00:53:00,260
container when it starts for the ng INX

1193
00:53:00,260 --> 00:53:03,110
image it is the ng INX command for the

1194
00:53:03,110 --> 00:53:06,260
MySQL image it is the MySQL D command

1195
00:53:06,260 --> 00:53:09,620
what we tried to do earlier was to run a

1196
00:53:09,620 --> 00:53:12,110
container with a plain Ubuntu operating

1197
00:53:12,110 --> 00:53:15,290
system let us look at the docker file

1198
00:53:15,290 --> 00:53:18,380
for this image you will see that it uses

1199
00:53:18,380 --> 00:53:22,700
bash as the default command now bash is

1200
00:53:22,700 --> 00:53:25,190
not really a process like a web server

1201
00:53:25,190 --> 00:53:28,400
or database server it is a shell that

1202
00:53:28,400 --> 00:53:31,370
listens for inputs from a terminal if it

1203
00:53:31,370 --> 00:53:34,700
cannot find the terminal it exits when

1204
00:53:34,700 --> 00:53:36,680
we ran the ubuntu container earlier

1205
00:53:36,680 --> 00:53:39,080
docker created a container from the

1206
00:53:39,080 --> 00:53:40,690
ubuntu image

1207
00:53:40,690 --> 00:53:43,210
launched the bash program by default

1208
00:53:43,210 --> 00:53:46,359
docker does not attach a terminal to a

1209
00:53:46,359 --> 00:53:49,329
container when it is run and so the bash

1210
00:53:49,329 --> 00:53:51,970
program does not find the terminal and

1211
00:53:51,970 --> 00:53:55,720
so it exits since the process that was

1212
00:53:55,720 --> 00:53:57,849
started when the container was created

1213
00:53:57,849 --> 00:54:01,990
finished the container exits as well so

1214
00:54:01,990 --> 00:54:04,569
how do you specify a different command

1215
00:54:04,569 --> 00:54:07,630
to start the container one option is to

1216
00:54:07,630 --> 00:54:10,000
append a command to the docker run

1217
00:54:10,000 --> 00:54:12,940
command and that way it overrides the

1218
00:54:12,940 --> 00:54:15,160
default command specified with him the

1219
00:54:15,160 --> 00:54:18,400
image in this case I run the docker run

1220
00:54:18,400 --> 00:54:21,220
Ubuntu command with the sleep 5 command

1221
00:54:21,220 --> 00:54:24,609
as the added option this way when the

1222
00:54:24,609 --> 00:54:26,770
container starts it runs the sleep

1223
00:54:26,770 --> 00:54:29,339
program waits for 5 seconds and then

1224
00:54:29,339 --> 00:54:32,230
exits but how do you make that change

1225
00:54:32,230 --> 00:54:35,020
permanent say you want the image to

1226
00:54:35,020 --> 00:54:37,180
always run the sleep command when it

1227
00:54:37,180 --> 00:54:39,819
starts you would then create your own

1228
00:54:39,819 --> 00:54:42,220
image from the base ubuntu image and

1229
00:54:42,220 --> 00:54:45,369
specify a new command there are

1230
00:54:45,369 --> 00:54:47,440
different ways of specifying the command

1231
00:54:47,440 --> 00:54:50,589
either the command simply as is in a

1232
00:54:50,589 --> 00:54:53,500
shell form or in a JSON array format

1233
00:54:53,500 --> 00:54:56,500
like this but remember when you specify

1234
00:54:56,500 --> 00:55:00,220
in a JSON array format the first element

1235
00:55:00,220 --> 00:55:02,589
in the array should be the executable in

1236
00:55:02,589 --> 00:55:05,650
this case the sleep program do not

1237
00:55:05,650 --> 00:55:07,930
specify the command and parameters

1238
00:55:07,930 --> 00:55:11,440
together like this the command and its

1239
00:55:11,440 --> 00:55:14,170
parameters should be separate elements

1240
00:55:14,170 --> 00:55:17,410
in the list so I now build my new image

1241
00:55:17,410 --> 00:55:20,589
using the docker build command and name

1242
00:55:20,589 --> 00:55:24,220
it as Ubuntu sleeper I could now simply

1243
00:55:24,220 --> 00:55:26,680
run the docker ubuntu sleeper command

1244
00:55:26,680 --> 00:55:29,710
and get the same results it always

1245
00:55:29,710 --> 00:55:34,030
sleeps for 5 seconds and exits but what

1246
00:55:34,030 --> 00:55:35,829
if I wished to change the number of

1247
00:55:35,829 --> 00:55:38,650
seconds it sleeps currently it is

1248
00:55:38,650 --> 00:55:39,520
hard-coded

1249
00:55:39,520 --> 00:55:42,940
to 5 seconds as we learned before one

1250
00:55:42,940 --> 00:55:45,550
option is to run the docker run command

1251
00:55:45,550 --> 00:55:47,890
with the new command appended to it in

1252
00:55:47,890 --> 00:55:51,160
this case sleep 10 and so the command

1253
00:55:51,160 --> 00:55:52,900
that will be run at startup will be

1254
00:55:52,900 --> 00:55:54,100
sleep 10

1255
00:55:54,100 --> 00:55:56,890
but it doesn't look very good the name

1256
00:55:56,890 --> 00:55:57,730
of the image

1257
00:55:57,730 --> 00:56:00,370
ubuntu sleeper in itself implies that

1258
00:56:00,370 --> 00:56:02,530
the container will sleep so we shouldn't

1259
00:56:02,530 --> 00:56:04,840
have to specify the sleep command again

1260
00:56:04,840 --> 00:56:07,390
instead we would like it to be something

1261
00:56:07,390 --> 00:56:11,370
like this docker run ubuntu sleeper 10

1262
00:56:11,370 --> 00:56:14,140
we only want to pass in the number of

1263
00:56:14,140 --> 00:56:16,210
seconds the container should sleep and

1264
00:56:16,210 --> 00:56:18,340
sleep command should be invoked

1265
00:56:18,340 --> 00:56:21,070
automatically and that is where the

1266
00:56:21,070 --> 00:56:23,490
entry point instructions comes into play

1267
00:56:23,490 --> 00:56:26,500
the entry point instruction is like the

1268
00:56:26,500 --> 00:56:28,690
command instruction as in you can

1269
00:56:28,690 --> 00:56:30,910
specify the program that will be run

1270
00:56:30,910 --> 00:56:33,580
when the container starts and whatever

1271
00:56:33,580 --> 00:56:36,190
you specify on the command line in this

1272
00:56:36,190 --> 00:56:39,160
case 10 will get appended to the entry

1273
00:56:39,160 --> 00:56:41,830
point so the command that will be run

1274
00:56:41,830 --> 00:56:45,850
when the container starts is sleep 10 so

1275
00:56:45,850 --> 00:56:47,890
that's the difference between the two in

1276
00:56:47,890 --> 00:56:51,130
case of the CMD instruction the command

1277
00:56:51,130 --> 00:56:53,770
line parameters passed will get replaced

1278
00:56:53,770 --> 00:56:56,830
entirely whereas in case of entry point

1279
00:56:56,830 --> 00:56:59,200
the command line parameters will get

1280
00:56:59,200 --> 00:57:02,830
appended now in the second case what if

1281
00:57:02,830 --> 00:57:05,350
I run the ubuntu sleeper image command

1282
00:57:05,350 --> 00:57:07,770
without appending the number of seconds

1283
00:57:07,770 --> 00:57:11,830
then the command at startup will be just

1284
00:57:11,830 --> 00:57:14,590
sleep and you get the error that the

1285
00:57:14,590 --> 00:57:17,170
operand is missing so how do you

1286
00:57:17,170 --> 00:57:19,540
configure a default value for the

1287
00:57:19,540 --> 00:57:22,570
command if one was not specified in the

1288
00:57:22,570 --> 00:57:24,970
command line that's where you would use

1289
00:57:24,970 --> 00:57:27,640
both entry point as well as the command

1290
00:57:27,640 --> 00:57:30,340
instruction in this case the command

1291
00:57:30,340 --> 00:57:32,710
instruction will be appended to the

1292
00:57:32,710 --> 00:57:35,530
entry point instruction so at startup

1293
00:57:35,530 --> 00:57:38,050
the command would be sleep 5 if you

1294
00:57:38,050 --> 00:57:40,120
didn't specify any parameters in the

1295
00:57:40,120 --> 00:57:43,000
command line if you did then that will

1296
00:57:43,000 --> 00:57:45,040
override the command instruction and

1297
00:57:45,040 --> 00:57:47,620
remember for this to happen you should

1298
00:57:47,620 --> 00:57:50,020
always specify the entry point and

1299
00:57:50,020 --> 00:57:53,520
command instructions in it JSON format

1300
00:57:53,520 --> 00:57:56,650
finally what if you really really want

1301
00:57:56,650 --> 00:57:59,730
to modify the entry point during runtime

1302
00:57:59,730 --> 00:58:04,060
say from sleep to an imaginary sleep 2.0

1303
00:58:04,060 --> 00:58:06,820
command well in that case you can

1304
00:58:06,820 --> 00:58:07,599
override

1305
00:58:07,599 --> 00:58:10,719
by using the entry point option in the

1306
00:58:10,719 --> 00:58:13,569
docker run command the final command a

1307
00:58:13,569 --> 00:58:18,910
startup would then be sleep 2.0 10 well

1308
00:58:18,910 --> 00:58:21,400
that's it for this lecture and I will

1309
00:58:21,400 --> 00:58:30,089
see you in the next we now look at

1310
00:58:30,089 --> 00:58:33,430
networking in docker when you install

1311
00:58:33,430 --> 00:58:35,920
docker it creates three networks

1312
00:58:35,920 --> 00:58:40,869
automatically bridge no and host bridge

1313
00:58:40,869 --> 00:58:43,420
is the default Network a container gets

1314
00:58:43,420 --> 00:58:45,670
attached to if you would like to

1315
00:58:45,670 --> 00:58:48,369
associate the container with any other

1316
00:58:48,369 --> 00:58:50,589
network is specified the network

1317
00:58:50,589 --> 00:58:53,140
information using the network command

1318
00:58:53,140 --> 00:58:56,799
line parameter like this we will now

1319
00:58:56,799 --> 00:59:00,339
look at each of these networks the BRIT

1320
00:59:00,339 --> 00:59:03,579
network is a private internal network

1321
00:59:03,579 --> 00:59:06,549
created by docker on the host all

1322
00:59:06,549 --> 00:59:09,130
containers attached to this network by

1323
00:59:09,130 --> 00:59:11,529
default and they get an internal IP

1324
00:59:11,529 --> 00:59:15,249
address usually in the range 170 2.17

1325
00:59:15,249 --> 00:59:18,459
series the containers can access each

1326
00:59:18,459 --> 00:59:21,779
other using this internal IP if required

1327
00:59:21,779 --> 00:59:24,640
to access any of these containers from

1328
00:59:24,640 --> 00:59:28,089
the outside world map the ports of these

1329
00:59:28,089 --> 00:59:30,699
containers to ports on the docker host

1330
00:59:30,699 --> 00:59:34,569
as we have seen before another way to

1331
00:59:34,569 --> 00:59:37,150
access the containers externally is to

1332
00:59:37,150 --> 00:59:39,039
associate the container to the hosts

1333
00:59:39,039 --> 00:59:42,130
network this takes out any network

1334
00:59:42,130 --> 00:59:44,289
isolation between the docker host and

1335
00:59:44,289 --> 00:59:46,779
the docker container meaning if you were

1336
00:59:46,779 --> 00:59:49,660
to run a web server on port 5000 in a

1337
00:59:49,660 --> 00:59:51,999
web app container it is automatically as

1338
00:59:51,999 --> 00:59:55,029
accessible on the same port externally

1339
00:59:55,029 --> 00:59:57,579
without requiring any port mapping as

1340
00:59:57,579 --> 01:00:00,779
the web container uses the hosts network

1341
01:00:00,779 --> 01:00:03,670
this would also mean that unlike before

1342
01:00:03,670 --> 01:00:07,180
you will now not be able to run multiple

1343
01:00:07,180 --> 01:00:09,819
web containers on the same host on the

1344
01:00:09,819 --> 01:00:12,969
same port as the ports are now common to

1345
01:00:12,969 --> 01:00:15,130
all containers in the host

1346
01:00:15,130 --> 01:00:19,599
network with the non network the

1347
01:00:19,599 --> 01:00:20,080
container

1348
01:00:20,080 --> 01:00:22,960
are not attached to any network and

1349
01:00:22,960 --> 01:00:25,900
doesn't have any access to the external

1350
01:00:25,900 --> 01:00:29,380
network or other containers they run in

1351
01:00:29,380 --> 01:00:34,600
an isolated Network so we just saw the

1352
01:00:34,600 --> 01:00:37,420
default burst network with the network

1353
01:00:37,420 --> 01:00:41,590
ID 170 2.72 0.1 so all containers

1354
01:00:41,590 --> 01:00:44,140
associated to this default network will

1355
01:00:44,140 --> 01:00:46,990
be able to communicate to each other but

1356
01:00:46,990 --> 01:00:48,880
what if we wish to isolate the

1357
01:00:48,880 --> 01:00:51,280
containers within the docker host for

1358
01:00:51,280 --> 01:00:53,770
example the first two web containers on

1359
01:00:53,770 --> 01:00:57,040
internal network 172 and the second two

1360
01:00:57,040 --> 01:00:58,990
containers on a different internal

1361
01:00:58,990 --> 01:01:04,390
network like 182 by default docker only

1362
01:01:04,390 --> 01:01:07,450
creates one internal bridge network we

1363
01:01:07,450 --> 01:01:09,670
could create our own internal network

1364
01:01:09,670 --> 01:01:12,460
using the command docker Network create

1365
01:01:12,460 --> 01:01:14,860
and specified the driver which is bridge

1366
01:01:14,860 --> 01:01:17,200
in this case and the subnet for that

1367
01:01:17,200 --> 01:01:19,360
network followed by the custom isolated

1368
01:01:19,360 --> 01:01:22,630
network name run the docker network LS

1369
01:01:22,630 --> 01:01:26,350
command to list all networks so how do

1370
01:01:26,350 --> 01:01:28,510
we see the network settings and the IP

1371
01:01:28,510 --> 01:01:30,460
address assigned to an existing

1372
01:01:30,460 --> 01:01:33,970
container run the docker inspect command

1373
01:01:33,970 --> 01:01:36,430
with the ID or name of the container and

1374
01:01:36,430 --> 01:01:38,890
you will find a section on network

1375
01:01:38,890 --> 01:01:41,830
settings there you can see the type of

1376
01:01:41,830 --> 01:01:44,110
network the container is attached to is

1377
01:01:44,110 --> 01:01:46,780
internal IP address MAC address and

1378
01:01:46,780 --> 01:01:52,600
other settings containers can reach each

1379
01:01:52,600 --> 01:01:55,270
other using their names for example in

1380
01:01:55,270 --> 01:01:58,390
this case I have a webserver and a MySQL

1381
01:01:58,390 --> 01:02:00,490
database container running on the same

1382
01:02:00,490 --> 01:02:03,340
node how can I get my web server to

1383
01:02:03,340 --> 01:02:05,410
access the database on the database

1384
01:02:05,410 --> 01:02:08,680
container one thing I could do is to use

1385
01:02:08,680 --> 01:02:11,140
the internal IP address signed to the

1386
01:02:11,140 --> 01:02:13,480
MySQL container which in this case is

1387
01:02:13,480 --> 01:02:18,010
170 2.72 0.3 but that is not very ideal

1388
01:02:18,010 --> 01:02:20,800
because it is not guaranteed that the

1389
01:02:20,800 --> 01:02:23,380
container will get the same IP when the

1390
01:02:23,380 --> 01:02:27,130
system reboots the right way to do it is

1391
01:02:27,130 --> 01:02:30,550
to use the container name all containers

1392
01:02:30,550 --> 01:02:32,650
in a docker host can resolve each

1393
01:02:32,650 --> 01:02:33,730
other.we

1394
01:02:33,730 --> 01:02:36,250
the name of the container docker has a

1395
01:02:36,250 --> 01:02:39,070
built-in DNS server that helps the

1396
01:02:39,070 --> 01:02:41,770
containers to resolve each other using

1397
01:02:41,770 --> 01:02:43,050
the container name

1398
01:02:43,050 --> 01:02:46,090
note that the built in DNS server always

1399
01:02:46,090 --> 01:02:50,850
runs at address 127 dot 0 dot 0 dot 11

1400
01:02:50,850 --> 01:02:55,109
so how does docker implement networking

1401
01:02:55,109 --> 01:02:57,940
what's the technology behind it like how

1402
01:02:57,940 --> 01:03:00,160
are the containers isolated within the

1403
01:03:00,160 --> 01:03:04,570
host docker uses network namespaces that

1404
01:03:04,570 --> 01:03:07,540
creates a separate name space for each

1405
01:03:07,540 --> 01:03:10,720
container it then uses virtual Ethernet

1406
01:03:10,720 --> 01:03:14,490
pairs to connect containers together

1407
01:03:14,490 --> 01:03:17,619
well that's all we can talk about it for

1408
01:03:17,619 --> 01:03:17,830
now

1409
01:03:17,830 --> 01:03:20,770
more about these are advanced concepts

1410
01:03:20,770 --> 01:03:23,440
that we discussed in the advanced course

1411
01:03:23,440 --> 01:03:27,490
on docker on code cloud that's all for

1412
01:03:27,490 --> 01:03:30,340
now from this lecture on networking head

1413
01:03:30,340 --> 01:03:32,260
over to the practice tests and practice

1414
01:03:32,260 --> 01:03:35,740
working with networking in docker I will

1415
01:03:35,740 --> 01:03:43,990
see you in the next lecture hello and

1416
01:03:43,990 --> 01:03:45,730
welcome to this lecture and we are

1417
01:03:45,730 --> 01:03:48,460
learning advanced docker concepts in

1418
01:03:48,460 --> 01:03:50,050
this lecture we're going to talk about

1419
01:03:50,050 --> 01:03:52,890
docker storage drivers and file systems

1420
01:03:52,890 --> 01:03:56,050
we're going to see where and how docker

1421
01:03:56,050 --> 01:03:58,720
stores data and how it manages file

1422
01:03:58,720 --> 01:04:02,320
systems of the containers let us start

1423
01:04:02,320 --> 01:04:05,140
with how docker stores data on the local

1424
01:04:05,140 --> 01:04:06,270
file system

1425
01:04:06,270 --> 01:04:09,550
when you install docker on a system it

1426
01:04:09,550 --> 01:04:13,000
creates this folder structure at where

1427
01:04:13,000 --> 01:04:16,119
lib docker you have multiple folders

1428
01:04:16,119 --> 01:04:19,450
under it called a ufs containers image

1429
01:04:19,450 --> 01:04:22,840
volumes etc this is where docker stores

1430
01:04:22,840 --> 01:04:26,440
all its data by default when I say data

1431
01:04:26,440 --> 01:04:28,960
I mean files related to images and

1432
01:04:28,960 --> 01:04:31,140
containers running on the docker host

1433
01:04:31,140 --> 01:04:34,390
for example all files related to

1434
01:04:34,390 --> 01:04:36,130
containers are stored under the

1435
01:04:36,130 --> 01:04:38,680
containers folder and the files related

1436
01:04:38,680 --> 01:04:40,840
to images are stored under the image

1437
01:04:40,840 --> 01:04:43,690
folder any volumes created by the docker

1438
01:04:43,690 --> 01:04:45,760
containers are created under the volumes

1439
01:04:45,760 --> 01:04:47,030
folder

1440
01:04:47,030 --> 01:04:48,920
well don't worry about that for now we

1441
01:04:48,920 --> 01:04:51,770
will come back to that in a bit for now

1442
01:04:51,770 --> 01:04:54,020
let's just understand where docker

1443
01:04:54,020 --> 01:04:58,940
stores its files and in what format so

1444
01:04:58,940 --> 01:05:01,160
how exactly does docker store the files

1445
01:05:01,160 --> 01:05:03,220
of an image and a container to

1446
01:05:03,220 --> 01:05:05,660
understand that we need to understand

1447
01:05:05,660 --> 01:05:09,080
Dockers layered architecture let's

1448
01:05:09,080 --> 01:05:11,090
quickly recap something we learned when

1449
01:05:11,090 --> 01:05:13,940
docker builds images it builds these in

1450
01:05:13,940 --> 01:05:17,000
a layered architecture each line of

1451
01:05:17,000 --> 01:05:19,820
instruction in the docker file creates a

1452
01:05:19,820 --> 01:05:22,640
new layer in the docker image with just

1453
01:05:22,640 --> 01:05:25,250
the changes from the previous layer for

1454
01:05:25,250 --> 01:05:28,220
example the first layer is a base Ubuntu

1455
01:05:28,220 --> 01:05:30,920
operating system followed by the second

1456
01:05:30,920 --> 01:05:33,230
instruction that creates a second layer

1457
01:05:33,230 --> 01:05:36,290
which installs all the apt packages and

1458
01:05:36,290 --> 01:05:38,570
then the third instruction creates a

1459
01:05:38,570 --> 01:05:41,150
third layer which with the Python

1460
01:05:41,150 --> 01:05:43,490
packages followed by the fourth layer

1461
01:05:43,490 --> 01:05:45,800
that copies the source code over and

1462
01:05:45,800 --> 01:05:48,260
then finally the fifth layer that

1463
01:05:48,260 --> 01:05:52,060
updates the entry point of the image

1464
01:05:52,060 --> 01:05:55,940
since each layer only stores the changes

1465
01:05:55,940 --> 01:05:58,520
from the previous layer it is reflected

1466
01:05:58,520 --> 01:06:01,400
in the size as well if you look at the

1467
01:06:01,400 --> 01:06:04,490
base open to image it is around 120

1468
01:06:04,490 --> 01:06:07,700
megabytes in size the apt packages that

1469
01:06:07,700 --> 01:06:10,820
I install is around 300 MB and then the

1470
01:06:10,820 --> 01:06:14,390
remaining layers are small to understand

1471
01:06:14,390 --> 01:06:16,520
the advantages of this layered

1472
01:06:16,520 --> 01:06:19,550
architecture let's consider a second

1473
01:06:19,550 --> 01:06:22,340
application this application has a

1474
01:06:22,340 --> 01:06:24,890
different talker file but it's very

1475
01:06:24,890 --> 01:06:27,680
similar to our first application as in

1476
01:06:27,680 --> 01:06:30,230
it uses the same base image as Ubuntu

1477
01:06:30,230 --> 01:06:32,900
uses the same Python and flask

1478
01:06:32,900 --> 01:06:36,290
dependencies but uses a different source

1479
01:06:36,290 --> 01:06:38,810
code to create a different application

1480
01:06:38,810 --> 01:06:41,630
and so a different entry point as well

1481
01:06:41,630 --> 01:06:44,510
when I run the docker build command to

1482
01:06:44,510 --> 01:06:46,510
build a new image for this application

1483
01:06:46,510 --> 01:06:49,880
since the first three layers of both the

1484
01:06:49,880 --> 01:06:52,490
applications are the same docker

1485
01:06:52,490 --> 01:06:55,010
is not going to build the first three

1486
01:06:55,010 --> 01:06:58,670
layers instead it reuses the same three

1487
01:06:58,670 --> 01:07:00,740
layers it built for the first

1488
01:07:00,740 --> 01:07:03,350
application from the cache and only

1489
01:07:03,350 --> 01:07:06,080
creates the last two layers with the new

1490
01:07:06,080 --> 01:07:09,890
sources and the new entry point this way

1491
01:07:09,890 --> 01:07:12,530
docker builds images faster and

1492
01:07:12,530 --> 01:07:16,130
efficiently saves disk space this is

1493
01:07:16,130 --> 01:07:18,410
also applicable if you were to update

1494
01:07:18,410 --> 01:07:21,020
your application code whenever you

1495
01:07:21,020 --> 01:07:23,810
update your application code such as the

1496
01:07:23,810 --> 01:07:25,670
app dot py in this case

1497
01:07:25,670 --> 01:07:28,820
docker simply reuses all the previous

1498
01:07:28,820 --> 01:07:31,610
layers from cache and quickly rebuilds

1499
01:07:31,610 --> 01:07:34,010
the application image by updating the

1500
01:07:34,010 --> 01:07:37,250
latest source code thus saving us a lot

1501
01:07:37,250 --> 01:07:42,010
of time hearing rebuilds and updates

1502
01:07:42,010 --> 01:07:45,440
let's rearrange the layers bottom up so

1503
01:07:45,440 --> 01:07:47,750
we can understand it better at the

1504
01:07:47,750 --> 01:07:50,030
bottom we have the base open to layer

1505
01:07:50,030 --> 01:07:53,450
than the packages then the dependencies

1506
01:07:53,450 --> 01:07:55,610
and then the source code of the

1507
01:07:55,610 --> 01:07:59,420
application and then the entry point all

1508
01:07:59,420 --> 01:08:02,240
of these layers are created when we run

1509
01:08:02,240 --> 01:08:04,580
the docker build command to form the

1510
01:08:04,580 --> 01:08:08,090
final docker image so all of these are

1511
01:08:08,090 --> 01:08:11,510
the docker image layers once the build

1512
01:08:11,510 --> 01:08:13,369
is complete you cannot modify the

1513
01:08:13,369 --> 01:08:15,920
contents of these layers and so they are

1514
01:08:15,920 --> 01:08:18,290
read-only and you can only modify them

1515
01:08:18,290 --> 01:08:22,009
by initiating a new build when you run a

1516
01:08:22,009 --> 01:08:24,859
container based off of this image using

1517
01:08:24,859 --> 01:08:27,560
the docker run command docker creates a

1518
01:08:27,560 --> 01:08:30,020
container based off of these layers and

1519
01:08:30,020 --> 01:08:33,170
creates a new writable layer on top of

1520
01:08:33,170 --> 01:08:35,779
the image layer the writable layer is

1521
01:08:35,779 --> 01:08:38,479
used to store data created by the

1522
01:08:38,479 --> 01:08:41,029
container such as log files written by

1523
01:08:41,029 --> 01:08:43,310
the applications any temporary files

1524
01:08:43,310 --> 01:08:45,830
generated by the container or just any

1525
01:08:45,830 --> 01:08:48,410
file modified by the user on that

1526
01:08:48,410 --> 01:08:51,319
container the life of this layer though

1527
01:08:51,319 --> 01:08:53,960
is only as long as the container is

1528
01:08:53,960 --> 01:08:56,330
alive when the container is destroyed

1529
01:08:56,330 --> 01:08:59,299
this layer and all of the changes stored

1530
01:08:59,299 --> 01:09:02,540
in it are also destroyed remember that

1531
01:09:02,540 --> 01:09:05,149
the same image layer is shared by all

1532
01:09:05,149 --> 01:09:10,069
containers created using this image if I

1533
01:09:10,069 --> 01:09:11,630
were to log in to the newly created

1534
01:09:11,630 --> 01:09:13,939
container and say create

1535
01:09:13,939 --> 01:09:17,750
a new file called temp dot txt it will

1536
01:09:17,750 --> 01:09:20,090
create that file in the container layer

1537
01:09:20,090 --> 01:09:23,210
which is read and write we just said

1538
01:09:23,210 --> 01:09:25,460
that the files in the image layer are

1539
01:09:25,460 --> 01:09:27,520
read-only meaning you cannot edit

1540
01:09:27,520 --> 01:09:30,979
anything in those layers let's take an

1541
01:09:30,979 --> 01:09:33,620
example of our application code since we

1542
01:09:33,620 --> 01:09:36,649
bake our code into the image the code is

1543
01:09:36,649 --> 01:09:38,899
part of the image layer and as such is

1544
01:09:38,899 --> 01:09:42,500
read-only after running a container what

1545
01:09:42,500 --> 01:09:45,050
if I wish to modify the source code to

1546
01:09:45,050 --> 01:09:48,470
say test a change remember the same

1547
01:09:48,470 --> 01:09:50,660
image layer may be shared between

1548
01:09:50,660 --> 01:09:52,970
multiple containers created from this

1549
01:09:52,970 --> 01:09:56,090
image so does it mean that I cannot

1550
01:09:56,090 --> 01:09:59,210
modify this file inside the container no

1551
01:09:59,210 --> 01:10:02,930
I can still modify this file but before

1552
01:10:02,930 --> 01:10:05,210
I save the modified file docker

1553
01:10:05,210 --> 01:10:07,580
automatically creates a copy of the file

1554
01:10:07,580 --> 01:10:10,070
in the readwrite layer and I will then

1555
01:10:10,070 --> 01:10:12,230
be modifying a different version of the

1556
01:10:12,230 --> 01:10:15,650
file in the readwrite layer all future

1557
01:10:15,650 --> 01:10:18,110
modifications will be done on this copy

1558
01:10:18,110 --> 01:10:21,050
of the file in the readwrite layer this

1559
01:10:21,050 --> 01:10:24,080
is called copy-on-write mechanism the

1560
01:10:24,080 --> 01:10:26,390
image layer being read-only just means

1561
01:10:26,390 --> 01:10:28,670
that the files in these layers will not

1562
01:10:28,670 --> 01:10:31,820
be modified in the image itself so the

1563
01:10:31,820 --> 01:10:34,070
image will remain the same all the time

1564
01:10:34,070 --> 01:10:37,070
until you rebuild the image using the

1565
01:10:37,070 --> 01:10:41,060
docker build command what happens when

1566
01:10:41,060 --> 01:10:43,730
we get rid of the container all of the

1567
01:10:43,730 --> 01:10:45,950
data that was stored in the container

1568
01:10:45,950 --> 01:10:49,490
layer also gets deleted the change we

1569
01:10:49,490 --> 01:10:52,370
made to the app dot py and the new temp

1570
01:10:52,370 --> 01:10:55,480
file we created we'll also get removed

1571
01:10:55,480 --> 01:10:58,400
so what if we wish to persist this data

1572
01:10:58,400 --> 01:11:00,920
for example if we were working with our

1573
01:11:00,920 --> 01:11:03,110
database and we would like to preserve

1574
01:11:03,110 --> 01:11:05,960
the data created by the container we

1575
01:11:05,960 --> 01:11:08,330
could add a persistent volume to the

1576
01:11:08,330 --> 01:11:11,690
container to do this first create a

1577
01:11:11,690 --> 01:11:14,060
volume using the docker volume create

1578
01:11:14,060 --> 01:11:17,240
command so when I run the docker volume

1579
01:11:17,240 --> 01:11:20,300
create data underscore volume command it

1580
01:11:20,300 --> 01:11:23,270
creates a folder called data underscore

1581
01:11:23,270 --> 01:11:27,080
volume under the var Lib docker

1582
01:11:27,080 --> 01:11:30,740
volumes directory then when I run the

1583
01:11:30,740 --> 01:11:32,630
docker container using the docker run

1584
01:11:32,630 --> 01:11:35,420
command I could mount this volume inside

1585
01:11:35,420 --> 01:11:37,340
the docker containers read/write layer

1586
01:11:37,340 --> 01:11:41,210
using the - B option like this so I

1587
01:11:41,210 --> 01:11:44,600
would do a docker run - V then specify

1588
01:11:44,600 --> 01:11:46,940
my newly created volume name followed by

1589
01:11:46,940 --> 01:11:49,550
a colon and the location inside my

1590
01:11:49,550 --> 01:11:51,740
container which is the default location

1591
01:11:51,740 --> 01:11:55,070
where MySQL stores data and that is

1592
01:11:55,070 --> 01:11:58,790
where Lib MySQL and then the image name

1593
01:11:58,790 --> 01:12:02,660
MySQL this will create a new container

1594
01:12:02,660 --> 01:12:05,300
and mount the data volume we created

1595
01:12:05,300 --> 01:12:08,720
into very Lib MySQL folder inside the

1596
01:12:08,720 --> 01:12:11,630
container so all data are written by the

1597
01:12:11,630 --> 01:12:14,390
database is in fact stored on the volume

1598
01:12:14,390 --> 01:12:17,900
created on the docker host even if the

1599
01:12:17,900 --> 01:12:20,750
container is destroyed the data is still

1600
01:12:20,750 --> 01:12:23,750
active now what if you didn't run the

1601
01:12:23,750 --> 01:12:25,820
docker volume create command to create

1602
01:12:25,820 --> 01:12:28,100
the volume before the docker run command

1603
01:12:28,100 --> 01:12:30,740
for example if I run the docker run

1604
01:12:30,740 --> 01:12:33,400
command to create a new instance of

1605
01:12:33,400 --> 01:12:36,530
MySQL container with the volume data

1606
01:12:36,530 --> 01:12:39,140
underscore volume to which I have not

1607
01:12:39,140 --> 01:12:42,320
created yet docker will automatically

1608
01:12:42,320 --> 01:12:45,230
create a volume named data underscore

1609
01:12:45,230 --> 01:12:47,920
volume - and mounted to the container

1610
01:12:47,920 --> 01:12:50,570
you should be able to see all these

1611
01:12:50,570 --> 01:12:53,510
volumes if you list the contents of the

1612
01:12:53,510 --> 01:12:58,010
where Lib docker volumes folder this is

1613
01:12:58,010 --> 01:13:01,010
called volume mounting as we are

1614
01:13:01,010 --> 01:13:03,050
mounting a volume created by docker

1615
01:13:03,050 --> 01:13:06,130
under the var Lib docker volumes folder

1616
01:13:06,130 --> 01:13:09,740
but what if we had our data already at

1617
01:13:09,740 --> 01:13:12,290
another location for example let's say

1618
01:13:12,290 --> 01:13:14,480
we have some external storage on the

1619
01:13:14,480 --> 01:13:18,200
docker host at four slash data and we

1620
01:13:18,200 --> 01:13:20,180
would like to store database data on

1621
01:13:20,180 --> 01:13:23,390
that volume and not in the default where

1622
01:13:23,390 --> 01:13:26,600
Lib docker volumes folder in that case

1623
01:13:26,600 --> 01:13:28,790
we would run a container using the

1624
01:13:28,790 --> 01:13:32,120
command docker run - V but in this case

1625
01:13:32,120 --> 01:13:34,580
we will provide the complete path to the

1626
01:13:34,580 --> 01:13:37,040
folder we would like to mount that is

1627
01:13:37,040 --> 01:13:40,820
for slash data for slash minus QL

1628
01:13:40,820 --> 01:13:43,190
so it will create a container and mount

1629
01:13:43,190 --> 01:13:46,579
the folder to the container this is

1630
01:13:46,579 --> 01:13:49,190
called bind mounting so there are two

1631
01:13:49,190 --> 01:13:51,829
types of mounts a volume mounting and a

1632
01:13:51,829 --> 01:13:54,800
bind mount volume mount mounts a volume

1633
01:13:54,800 --> 01:13:57,260
from the volumes directory and bind

1634
01:13:57,260 --> 01:14:00,110
mount mounts a directory from any

1635
01:14:00,110 --> 01:14:03,130
location on the docker host

1636
01:14:03,130 --> 01:14:06,340
one final point note before I let you go

1637
01:14:06,340 --> 01:14:10,300
you think the - V is an old style the

1638
01:14:10,300 --> 01:14:14,410
new way is to use - mount option the - -

1639
01:14:14,410 --> 01:14:17,230
mount is the preferred way as it is more

1640
01:14:17,230 --> 01:14:20,020
verbose so you have to specify each

1641
01:14:20,020 --> 01:14:22,840
parameter in a key equals value format

1642
01:14:22,840 --> 01:14:25,810
for example the previous command can be

1643
01:14:25,810 --> 01:14:28,270
written with the - mount option as this

1644
01:14:28,270 --> 01:14:31,620
using the type source and target options

1645
01:14:31,620 --> 01:14:35,200
the type in this case is bind the source

1646
01:14:35,200 --> 01:14:38,560
is the location on my host and target is

1647
01:14:38,560 --> 01:14:44,440
the location on my container so who is

1648
01:14:44,440 --> 01:14:46,300
responsible for doing all of these

1649
01:14:46,300 --> 01:14:48,760
operations maintaining the layered

1650
01:14:48,760 --> 01:14:51,280
architecture creating a writable layer

1651
01:14:51,280 --> 01:14:53,950
moving files across layers to enable

1652
01:14:53,950 --> 01:14:56,830
copy and write etc it's the storage

1653
01:14:56,830 --> 01:14:59,740
drivers so Dockery uses storage drivers

1654
01:14:59,740 --> 01:15:02,680
to enable layered architecture some of

1655
01:15:02,680 --> 01:15:05,820
the common storage drivers are au FS

1656
01:15:05,820 --> 01:15:10,840
btrfs ZFS device mapper overlay and

1657
01:15:10,840 --> 01:15:13,900
overlay to the selection of the storage

1658
01:15:13,900 --> 01:15:15,970
driver depends on the underlying OS

1659
01:15:15,970 --> 01:15:19,090
being used for example we to bond to the

1660
01:15:19,090 --> 01:15:22,210
default storage driver is a u FS whereas

1661
01:15:22,210 --> 01:15:24,280
this storage driver is not available on

1662
01:15:24,280 --> 01:15:26,650
other operating systems like fedora or

1663
01:15:26,650 --> 01:15:30,580
cent OS in that case device mapper may

1664
01:15:30,580 --> 01:15:33,430
be a better option docker will choose

1665
01:15:33,430 --> 01:15:35,590
the best storage driver available

1666
01:15:35,590 --> 01:15:37,960
automatically based on the operating

1667
01:15:37,960 --> 01:15:40,510
system the different storage drivers

1668
01:15:40,510 --> 01:15:43,120
also provide different performance and

1669
01:15:43,120 --> 01:15:46,180
stability characteristics so you may

1670
01:15:46,180 --> 01:15:48,040
want to choose one that fits the needs

1671
01:15:48,040 --> 01:15:50,110
of your application and your

1672
01:15:50,110 --> 01:15:52,450
organization if you would like to read

1673
01:15:52,450 --> 01:15:54,520
more on any of these storage drivers

1674
01:15:54,520 --> 01:15:56,740
please refer to the links in the

1675
01:15:56,740 --> 01:16:00,040
attached documentation for now that is

1676
01:16:00,040 --> 01:16:02,560
all from the docker architecture

1677
01:16:02,560 --> 01:16:07,260
concepts see you in the next lecture

1678
01:16:07,690 --> 01:16:10,750
[Music]

1679
01:16:12,870 --> 01:16:16,360
[Music]

1680
01:16:16,360 --> 01:16:18,829
hello and welcome to this lecture on

1681
01:16:18,829 --> 01:16:22,639
docker compose going forward we will be

1682
01:16:22,639 --> 01:16:25,519
working with configurations in yamo file

1683
01:16:25,519 --> 01:16:27,860
so it is important that you are

1684
01:16:27,860 --> 01:16:31,639
comfortable with llamo let's recap a few

1685
01:16:31,639 --> 01:16:34,400
things real quick course we first

1686
01:16:34,400 --> 01:16:36,769
learned how to run a docker container

1687
01:16:36,769 --> 01:16:39,920
using the docker run command if we

1688
01:16:39,920 --> 01:16:41,920
needed to set up a complex application

1689
01:16:41,920 --> 01:16:45,559
running multiple services a better way

1690
01:16:45,559 --> 01:16:49,190
to do it is to use docker compose with

1691
01:16:49,190 --> 01:16:51,289
docker compose we could create a

1692
01:16:51,289 --> 01:16:54,139
configuration file in yamo format called

1693
01:16:54,139 --> 01:16:57,409
docker compose Gemmell and put together

1694
01:16:57,409 --> 01:17:00,949
the different services and the options

1695
01:17:00,949 --> 01:17:03,979
specific to this to running them in this

1696
01:17:03,979 --> 01:17:07,550
file then we could simply run a docker

1697
01:17:07,550 --> 01:17:09,739
compose up command to bring up the

1698
01:17:09,739 --> 01:17:12,979
entire application stack this is easier

1699
01:17:12,979 --> 01:17:15,499
to implement run and maintain as all

1700
01:17:15,499 --> 01:17:17,659
changes are always stored in the docker

1701
01:17:17,659 --> 01:17:20,960
compose configuration file however this

1702
01:17:20,960 --> 01:17:23,059
is all only applicable to running

1703
01:17:23,059 --> 01:17:26,110
containers on a single docker host and

1704
01:17:26,110 --> 01:17:29,090
for now don't worry about the yamo file

1705
01:17:29,090 --> 01:17:31,249
we will take a closer look at the yamo

1706
01:17:31,249 --> 01:17:33,679
file in a bit and see how to put it

1707
01:17:33,679 --> 01:17:36,469
together that was a really simple

1708
01:17:36,469 --> 01:17:39,139
application that I put together let us

1709
01:17:39,139 --> 01:17:41,900
look at a better example I'm going to

1710
01:17:41,900 --> 01:17:44,090
use the same sample application that

1711
01:17:44,090 --> 01:17:47,210
everyone uses to demonstrate docker it's

1712
01:17:47,210 --> 01:17:49,780
a simple yet comprehensive application

1713
01:17:49,780 --> 01:17:52,909
developed by docker to demonstrate the

1714
01:17:52,909 --> 01:17:55,280
various features available in running an

1715
01:17:55,280 --> 01:17:57,429
application stack on docker

1716
01:17:57,429 --> 01:18:00,920
so let's first get familiarized with the

1717
01:18:00,920 --> 01:18:03,409
application because we will be working

1718
01:18:03,409 --> 01:18:05,809
with the same application in different

1719
01:18:05,809 --> 01:18:08,710
sections through the rest of this course

1720
01:18:08,710 --> 01:18:11,119
this is a sample voting application

1721
01:18:11,119 --> 01:18:14,659
which provides an interface for a user

1722
01:18:14,659 --> 01:18:18,050
to vote and another interface to show

1723
01:18:18,050 --> 01:18:20,929
the results the application consists of

1724
01:18:20,929 --> 01:18:22,829
various components such as

1725
01:18:22,829 --> 01:18:24,840
the voting app which is a web

1726
01:18:24,840 --> 01:18:27,360
application developed in Python to

1727
01:18:27,360 --> 01:18:29,909
provide the user with an interface to

1728
01:18:29,909 --> 01:18:32,940
choose between two options a cat and a

1729
01:18:32,940 --> 01:18:36,690
dog when you make a selection the vote

1730
01:18:36,690 --> 01:18:40,170
is stored in Redis for those of you who

1731
01:18:40,170 --> 01:18:42,210
are new to Redis Redis in this case

1732
01:18:42,210 --> 01:18:45,570
serves as a database in memory this load

1733
01:18:45,570 --> 01:18:47,909
is then processed by the worker which is

1734
01:18:47,909 --> 01:18:50,309
an application written in dotnet the

1735
01:18:50,309 --> 01:18:52,559
worker application takes the new vote

1736
01:18:52,559 --> 01:18:54,960
and updates the persistent database

1737
01:18:54,960 --> 01:18:58,650
which is a Postgres SQL in our case the

1738
01:18:58,650 --> 01:19:01,590
Postgres SQL simply has a table with the

1739
01:19:01,590 --> 01:19:04,260
number of votes for each category cats

1740
01:19:04,260 --> 01:19:07,380
and dogs in this case it increments the

1741
01:19:07,380 --> 01:19:09,989
number of votes for cats as our what was

1742
01:19:09,989 --> 01:19:13,020
for cats finally the result of the vote

1743
01:19:13,020 --> 01:19:15,270
is displayed in a web interface which is

1744
01:19:15,270 --> 01:19:17,760
another web application developed in

1745
01:19:17,760 --> 01:19:21,420
node.js this resulting application reads

1746
01:19:21,420 --> 01:19:23,579
the count of votes from the Postgres

1747
01:19:23,579 --> 01:19:26,429
sequel database and displays it to the

1748
01:19:26,429 --> 01:19:29,699
user so that is the architecture and

1749
01:19:29,699 --> 01:19:32,940
data flow of this simple voting

1750
01:19:32,940 --> 01:19:36,300
application stack as you can see this

1751
01:19:36,300 --> 01:19:38,820
sample application is built with a

1752
01:19:38,820 --> 01:19:41,070
combination of different services

1753
01:19:41,070 --> 01:19:43,980
different development tools and multiple

1754
01:19:43,980 --> 01:19:46,409
different development platforms such as

1755
01:19:46,409 --> 01:19:51,540
Python node.js net etc this sample

1756
01:19:51,540 --> 01:19:54,420
application will be used to showcase how

1757
01:19:54,420 --> 01:19:56,579
easy it is to set up an entire

1758
01:19:56,579 --> 01:19:59,579
application stack consisting of diverse

1759
01:19:59,579 --> 01:20:03,599
components in docker let us keep aside

1760
01:20:03,599 --> 01:20:06,929
docker swarm services and stacks for a

1761
01:20:06,929 --> 01:20:09,210
minute and see how we can put together

1762
01:20:09,210 --> 01:20:12,540
this application stack on a single

1763
01:20:12,540 --> 01:20:16,469
docker engine using first docker run

1764
01:20:16,469 --> 01:20:20,159
commands and then docker compose let us

1765
01:20:20,159 --> 01:20:23,040
assume that all images of applications

1766
01:20:23,040 --> 01:20:25,619
are already built and are available on

1767
01:20:25,619 --> 01:20:28,739
docker repository let us start with the

1768
01:20:28,739 --> 01:20:31,380
data layer first we run the docker run

1769
01:20:31,380 --> 01:20:34,349
command to start an instance of Redis by

1770
01:20:34,349 --> 01:20:36,570
running the docker run Redis command

1771
01:20:36,570 --> 01:20:39,690
we will add the dash D parameter to run

1772
01:20:39,690 --> 01:20:42,210
this container in the background and we

1773
01:20:42,210 --> 01:20:46,080
will also name the container Redis now

1774
01:20:46,080 --> 01:20:49,320
naming the containers is important why

1775
01:20:49,320 --> 01:20:50,280
is that important

1776
01:20:50,280 --> 01:20:52,320
hold that thought we will come to that

1777
01:20:52,320 --> 01:20:55,560
in a bit next we will deploy the

1778
01:20:55,560 --> 01:20:57,900
Postgres sequel database by running the

1779
01:20:57,900 --> 01:21:01,860
docker run Postgres command this time -

1780
01:21:01,860 --> 01:21:04,920
we will add the - d option to run this

1781
01:21:04,920 --> 01:21:06,930
in the background and name this

1782
01:21:06,930 --> 01:21:11,100
container DB for database next we will

1783
01:21:11,100 --> 01:21:14,010
start with the application services we

1784
01:21:14,010 --> 01:21:15,840
will deploy a front-end app for voting

1785
01:21:15,840 --> 01:21:17,820
interface by running an instance of

1786
01:21:17,820 --> 01:21:20,940
voting app image run the docker run

1787
01:21:20,940 --> 01:21:23,970
command and name the instance vote since

1788
01:21:23,970 --> 01:21:26,220
this is a web server it has a web UI

1789
01:21:26,220 --> 01:21:29,100
instance running on port 80 we will

1790
01:21:29,100 --> 01:21:31,440
publish that port to 5000 on the host

1791
01:21:31,440 --> 01:21:33,780
system so we can access it from a

1792
01:21:33,780 --> 01:21:36,600
browser next we will deploy the result

1793
01:21:36,600 --> 01:21:39,270
web application that shows the results

1794
01:21:39,270 --> 01:21:41,970
to the user for this we deploy a

1795
01:21:41,970 --> 01:21:44,940
container using the results - app image

1796
01:21:44,940 --> 01:21:48,390
and publish port 80 - port 5001 on the

1797
01:21:48,390 --> 01:21:51,150
host this way we can access the web UI

1798
01:21:51,150 --> 01:21:53,750
of the resulting app on a browser

1799
01:21:53,750 --> 01:21:56,610
finally we deploy the worker by running

1800
01:21:56,610 --> 01:22:02,010
an instance of the worker image okay now

1801
01:22:02,010 --> 01:22:04,350
this is all good and we can see that all

1802
01:22:04,350 --> 01:22:06,860
the instances are running on the host

1803
01:22:06,860 --> 01:22:10,500
but there is some problem it just does

1804
01:22:10,500 --> 01:22:13,530
not seem to work the problem is that we

1805
01:22:13,530 --> 01:22:15,660
have successfully run all the different

1806
01:22:15,660 --> 01:22:17,660
containers but we haven't actually

1807
01:22:17,660 --> 01:22:20,880
linked them together as in we haven't

1808
01:22:20,880 --> 01:22:23,400
told the voting web application to use

1809
01:22:23,400 --> 01:22:26,280
this particular Redis instance there

1810
01:22:26,280 --> 01:22:28,320
could be multiple Redis instances

1811
01:22:28,320 --> 01:22:31,260
running we haven't told the worker and

1812
01:22:31,260 --> 01:22:33,690
the resulting app to use this particular

1813
01:22:33,690 --> 01:22:37,320
Postgres equal database that we ran so

1814
01:22:37,320 --> 01:22:40,080
how do we do that that is where we use

1815
01:22:40,080 --> 01:22:43,770
links link is a command line option

1816
01:22:43,770 --> 01:22:46,530
which can be used to link two containers

1817
01:22:46,530 --> 01:22:49,930
together for example the voltage

1818
01:22:49,930 --> 01:22:52,570
app web service is dependent on the

1819
01:22:52,570 --> 01:22:55,630
Redis service when the web server starts

1820
01:22:55,630 --> 01:22:58,060
as you can see in this piece of code on

1821
01:22:58,060 --> 01:23:00,850
the web server it looks for a Redis

1822
01:23:00,850 --> 01:23:04,270
service running on host Redis but the

1823
01:23:04,270 --> 01:23:06,550
voting app container cannot resolve a

1824
01:23:06,550 --> 01:23:09,550
host by the name Redis to make the

1825
01:23:09,550 --> 01:23:12,490
voting app aware of the Redis service we

1826
01:23:12,490 --> 01:23:14,560
add a link option while running the

1827
01:23:14,560 --> 01:23:17,140
voting app container to link it to the

1828
01:23:17,140 --> 01:23:20,830
Redis container adding a - - link option

1829
01:23:20,830 --> 01:23:23,320
to the docker run command and specifying

1830
01:23:23,320 --> 01:23:25,630
the name of the Redis container which is

1831
01:23:25,630 --> 01:23:28,330
which in this case is Redis followed by

1832
01:23:28,330 --> 01:23:30,820
a colon and the name of the host that

1833
01:23:30,820 --> 01:23:33,130
the voting app is looking for which is

1834
01:23:33,130 --> 01:23:36,490
also Redis in this case remember that

1835
01:23:36,490 --> 01:23:39,640
this is why we named the container when

1836
01:23:39,640 --> 01:23:41,860
we ran it the first time so we could use

1837
01:23:41,860 --> 01:23:46,060
its name while creating a link what this

1838
01:23:46,060 --> 01:23:48,910
is in fact doing is it creates an entry

1839
01:23:48,910 --> 01:23:51,220
into the e.t.c host file on the voting

1840
01:23:51,220 --> 01:23:53,590
app container adding an entry with a

1841
01:23:53,590 --> 01:23:56,230
host name Redis with an internal IP of

1842
01:23:56,230 --> 01:23:57,870
the Redis container

1843
01:23:57,870 --> 01:24:01,090
similarly we add a link for the result

1844
01:24:01,090 --> 01:24:03,370
app to communicate with the database by

1845
01:24:03,370 --> 01:24:06,160
adding a link option to refer the

1846
01:24:06,160 --> 01:24:09,490
database by the name DB as you can see

1847
01:24:09,490 --> 01:24:11,080
in this source code of the application

1848
01:24:11,080 --> 01:24:13,870
it makes an attempt to connect to a

1849
01:24:13,870 --> 01:24:18,490
Postgres database on hosts DB finally

1850
01:24:18,490 --> 01:24:20,650
the worker application requires access

1851
01:24:20,650 --> 01:24:23,050
to both the Redis as well as the

1852
01:24:23,050 --> 01:24:26,440
Postgres database so we add two links to

1853
01:24:26,440 --> 01:24:29,320
the worker application one link to link

1854
01:24:29,320 --> 01:24:31,390
the Redis and the other link to link

1855
01:24:31,390 --> 01:24:36,310
Postgres database note that using links

1856
01:24:36,310 --> 01:24:39,100
this way is deprecated and the support

1857
01:24:39,100 --> 01:24:43,120
may be removed in future in docker this

1858
01:24:43,120 --> 01:24:45,870
is because as we will see in some time

1859
01:24:45,870 --> 01:24:48,550
advanced and newer concepts in docker

1860
01:24:48,550 --> 01:24:51,130
swarm and networking supports better

1861
01:24:51,130 --> 01:24:53,980
ways of achieving what we just did here

1862
01:24:53,980 --> 01:24:56,740
with links but I wanted to mention that

1863
01:24:56,740 --> 01:24:59,470
anyway so you learned the concept from

1864
01:24:59,470 --> 01:25:02,870
the very basics once we have the

1865
01:25:02,870 --> 01:25:05,450
run commands tested and ready it is easy

1866
01:25:05,450 --> 01:25:07,640
to generate a docker compose file from

1867
01:25:07,640 --> 01:25:10,580
it we start by creating a dictionary of

1868
01:25:10,580 --> 01:25:12,800
container names we will use the same

1869
01:25:12,800 --> 01:25:14,960
name we used in the docker run commands

1870
01:25:14,960 --> 01:25:17,330
so we take all the names and create a

1871
01:25:17,330 --> 01:25:18,950
key with each of them

1872
01:25:18,950 --> 01:25:22,190
then under each item we specify which

1873
01:25:22,190 --> 01:25:25,790
image to use the key is the image and

1874
01:25:25,790 --> 01:25:28,130
the value is the name of the image to

1875
01:25:28,130 --> 01:25:31,580
use next inspect the commands and see

1876
01:25:31,580 --> 01:25:33,920
what are the other options used we

1877
01:25:33,920 --> 01:25:36,230
published ports so let's move those

1878
01:25:36,230 --> 01:25:39,590
ports under the respective containers so

1879
01:25:39,590 --> 01:25:41,870
we create a property called ports and

1880
01:25:41,870 --> 01:25:43,700
lists all the ports that you would like

1881
01:25:43,700 --> 01:25:46,790
to publish under that finally we are

1882
01:25:46,790 --> 01:25:49,820
left with links so whichever container

1883
01:25:49,820 --> 01:25:52,430
requires a link created properly under

1884
01:25:52,430 --> 01:25:54,950
it called links and provide an array of

1885
01:25:54,950 --> 01:26:00,290
links such as Redis or TB note that you

1886
01:26:00,290 --> 01:26:02,720
could also specify the name of the link

1887
01:26:02,720 --> 01:26:05,480
this way without the semicolon and and

1888
01:26:05,480 --> 01:26:08,150
the target target name and it will

1889
01:26:08,150 --> 01:26:11,030
create a link with the same name as the

1890
01:26:11,030 --> 01:26:14,720
target name specifying the DB : DB is

1891
01:26:14,720 --> 01:26:18,590
similar to simply specify dB we will

1892
01:26:18,590 --> 01:26:22,030
assume the same value to create a link

1893
01:26:22,030 --> 01:26:24,560
now that we are all done with our docker

1894
01:26:24,560 --> 01:26:26,840
compose file bringing up the stack is

1895
01:26:26,840 --> 01:26:29,420
really simple from the docker compose up

1896
01:26:29,420 --> 01:26:31,160
command to bring up the entire

1897
01:26:31,160 --> 01:26:39,340
application stack when we looked

1898
01:26:39,340 --> 01:26:41,170
example of the sample voting application

1899
01:26:41,170 --> 01:26:44,770
we assumed that all images are already

1900
01:26:44,770 --> 01:26:47,650
built out of the five different

1901
01:26:47,650 --> 01:26:50,199
components two of them Redis and

1902
01:26:50,199 --> 01:26:52,690
Postgres images we know are already

1903
01:26:52,690 --> 01:26:55,030
available on docker hub there are

1904
01:26:55,030 --> 01:26:58,290
official images from Redis and Postgres

1905
01:26:58,290 --> 01:27:01,000
but the remaining three are our own

1906
01:27:01,000 --> 01:27:03,730
application it is not necessary that

1907
01:27:03,730 --> 01:27:05,889
they are already built and available in

1908
01:27:05,889 --> 01:27:08,590
a docker registry if we would like to

1909
01:27:08,590 --> 01:27:11,560
instruct docker compose to run a docker

1910
01:27:11,560 --> 01:27:13,810
build instead of trying to pull an image

1911
01:27:13,810 --> 01:27:16,840
we can replace the image line with a

1912
01:27:16,840 --> 01:27:19,540
build line and specify the location of a

1913
01:27:19,540 --> 01:27:22,030
directory which contains the application

1914
01:27:22,030 --> 01:27:24,820
code and a docker file with instructions

1915
01:27:24,820 --> 01:27:27,489
to build the docker image in this

1916
01:27:27,489 --> 01:27:30,639
example for the voting app have all the

1917
01:27:30,639 --> 01:27:33,730
application code in a folder named vote

1918
01:27:33,730 --> 01:27:37,150
which contains all application code and

1919
01:27:37,150 --> 01:27:40,270
a docker file this time when you run the

1920
01:27:40,270 --> 01:27:42,820
docker compose up command it will first

1921
01:27:42,820 --> 01:27:45,550
build the images give a temporary name

1922
01:27:45,550 --> 01:27:48,400
for it and then use those images to run

1923
01:27:48,400 --> 01:27:50,380
containers using the options you

1924
01:27:50,380 --> 01:27:54,810
specified before similarly use build

1925
01:27:54,810 --> 01:27:58,179
option to build the two other services

1926
01:27:58,179 --> 01:28:03,159
from the respective folders we will now

1927
01:28:03,159 --> 01:28:05,560
look at different versions of docker

1928
01:28:05,560 --> 01:28:08,020
compose file this is important because

1929
01:28:08,020 --> 01:28:11,080
you might see docker compose files in

1930
01:28:11,080 --> 01:28:13,420
different formats at different places

1931
01:28:13,420 --> 01:28:16,020
and wonder white-sand look different

1932
01:28:16,020 --> 01:28:19,510
docker compose evolved over time and now

1933
01:28:19,510 --> 01:28:22,150
supports a lot more options than it did

1934
01:28:22,150 --> 01:28:25,210
in the beginning for example this is the

1935
01:28:25,210 --> 01:28:27,550
trimmed down version of the docker

1936
01:28:27,550 --> 01:28:30,610
compose file we used earlier this is in

1937
01:28:30,610 --> 01:28:33,310
fact the original version of docker

1938
01:28:33,310 --> 01:28:37,270
compose file known as version 1 this had

1939
01:28:37,270 --> 01:28:39,639
a number of limitations for example if

1940
01:28:39,639 --> 01:28:41,920
you wanted to deploy containers on a

1941
01:28:41,920 --> 01:28:44,920
different network other than the default

1942
01:28:44,920 --> 01:28:47,500
bridge network there was no way of

1943
01:28:47,500 --> 01:28:49,929
specifying that in this version of the

1944
01:28:49,929 --> 01:28:53,079
file also say you have a dependency

1945
01:28:53,079 --> 01:28:54,969
or startup order of some kind for

1946
01:28:54,969 --> 01:28:57,400
example your database container must

1947
01:28:57,400 --> 01:28:59,889
come up first and only then and should

1948
01:28:59,889 --> 01:29:02,440
the voting application be started there

1949
01:29:02,440 --> 01:29:04,510
was no way you could specify that in the

1950
01:29:04,510 --> 01:29:08,219
ocean one of the docker compose file

1951
01:29:08,219 --> 01:29:12,400
support for these came in version 2 with

1952
01:29:12,400 --> 01:29:15,610
version 2 and up the format of the file

1953
01:29:15,610 --> 01:29:18,869
also changed a little bit you no longer

1954
01:29:18,869 --> 01:29:21,730
specify your stack information directly

1955
01:29:21,730 --> 01:29:25,179
as you did before it is all encapsulated

1956
01:29:25,179 --> 01:29:27,699
in a Services section so create a

1957
01:29:27,699 --> 01:29:30,520
property called services in the root of

1958
01:29:30,520 --> 01:29:33,070
the file and then move all the services

1959
01:29:33,070 --> 01:29:36,369
underneath that you will still use the

1960
01:29:36,369 --> 01:29:38,860
same docker compose up command to bring

1961
01:29:38,860 --> 01:29:41,829
up your application stack but how does

1962
01:29:41,829 --> 01:29:44,530
docker compose know what version of the

1963
01:29:44,530 --> 01:29:47,290
file you're using you're free to use

1964
01:29:47,290 --> 01:29:49,809
version 1 or version 2 depending on your

1965
01:29:49,809 --> 01:29:52,440
needs so how does the docker compose

1966
01:29:52,440 --> 01:29:56,800
know what format you are using for

1967
01:29:56,800 --> 01:29:59,800
version 2 and up you must specify the

1968
01:29:59,800 --> 01:30:02,170
version of docker compose file you are

1969
01:30:02,170 --> 01:30:04,389
intending to use by specifying the

1970
01:30:04,389 --> 01:30:07,329
version at the top of the file in this

1971
01:30:07,329 --> 01:30:12,400
case version : 2 another difference is

1972
01:30:12,400 --> 01:30:16,239
with networking in version 1 docker

1973
01:30:16,239 --> 01:30:18,849
compose attaches all the containers it

1974
01:30:18,849 --> 01:30:22,349
runs to the default bridged Network and

1975
01:30:22,349 --> 01:30:25,420
then use links to enable communication

1976
01:30:25,420 --> 01:30:27,690
between the containers as we did before

1977
01:30:27,690 --> 01:30:31,780
with version 2 dr. Campos automatically

1978
01:30:31,780 --> 01:30:34,750
creates a dedicated bridged Network for

1979
01:30:34,750 --> 01:30:37,420
this application and then attaches all

1980
01:30:37,420 --> 01:30:41,020
containers to that new network all

1981
01:30:41,020 --> 01:30:43,300
containers are then able to communicate

1982
01:30:43,300 --> 01:30:46,150
to each other using each other's service

1983
01:30:46,150 --> 01:30:46,630
name

1984
01:30:46,630 --> 01:30:49,690
so you basically don't need to use links

1985
01:30:49,690 --> 01:30:52,809
in version 2 of docker compose you can

1986
01:30:52,809 --> 01:30:55,239
simply get rid of all the links you

1987
01:30:55,239 --> 01:30:58,000
mentioned in version 1 when you convert

1988
01:30:58,000 --> 01:31:01,570
a file from version one to version two

1989
01:31:01,570 --> 01:31:04,719
and finally version 2 also introduces it

1990
01:31:04,719 --> 01:31:07,210
depends on feature if you wish to

1991
01:31:07,210 --> 01:31:08,860
specify a startup

1992
01:31:08,860 --> 01:31:11,469
order for instance say the watering web

1993
01:31:11,469 --> 01:31:14,260
application is dependent on the Redis

1994
01:31:14,260 --> 01:31:16,599
service so you need to ensure that Redis

1995
01:31:16,599 --> 01:31:19,360
container is started first and only then

1996
01:31:19,360 --> 01:31:21,159
the voting web application must be

1997
01:31:21,159 --> 01:31:24,040
started we could add a depends on

1998
01:31:24,040 --> 01:31:26,130
property to the voting application and

1999
01:31:26,130 --> 01:31:30,690
indicate that it is dependent on Redis

2000
01:31:30,690 --> 01:31:34,389
then comes version 3 which is the latest

2001
01:31:34,389 --> 01:31:38,320
as of today version 3 is similar to

2002
01:31:38,320 --> 01:31:41,020
version 2 in the structure meaning it

2003
01:31:41,020 --> 01:31:43,030
has a version specification at the top

2004
01:31:43,030 --> 01:31:45,219
and a Services section under which you

2005
01:31:45,219 --> 01:31:47,530
put all your services just like in

2006
01:31:47,530 --> 01:31:50,409
version 2 make sure to specify the

2007
01:31:50,409 --> 01:31:54,520
version number as 3 at the top version 3

2008
01:31:54,520 --> 01:31:56,710
comes with support for docker swamp

2009
01:31:56,710 --> 01:31:59,530
which we will see later on there are

2010
01:31:59,530 --> 01:32:01,810
some options that were removed and added

2011
01:32:01,810 --> 01:32:04,570
to see details on those you can refer to

2012
01:32:04,570 --> 01:32:07,210
the documentation section using the link

2013
01:32:07,210 --> 01:32:08,920
in the reference page following this

2014
01:32:08,920 --> 01:32:12,190
lecture we will see version 3 in much

2015
01:32:12,190 --> 01:32:14,409
detail later when we discuss about

2016
01:32:14,409 --> 01:32:19,179
docker stacks let us talk about networks

2017
01:32:19,179 --> 01:32:22,210
in docker compose getting back to our

2018
01:32:22,210 --> 01:32:25,210
application so far we have been just

2019
01:32:25,210 --> 01:32:27,909
deploying all containers on the default

2020
01:32:27,909 --> 01:32:31,630
bridged Network let us say we modify the

2021
01:32:31,630 --> 01:32:34,179
architecture a little bit to contain the

2022
01:32:34,179 --> 01:32:36,400
traffic from the different sources for

2023
01:32:36,400 --> 01:32:38,770
example we would like to separate the

2024
01:32:38,770 --> 01:32:40,570
user generated traffic from the

2025
01:32:40,570 --> 01:32:43,090
applications internal traffic so we

2026
01:32:43,090 --> 01:32:45,610
create a front-end network dedicated for

2027
01:32:45,610 --> 01:32:48,280
traffic from users and a back-end

2028
01:32:48,280 --> 01:32:51,070
network dedicated for traffic within the

2029
01:32:51,070 --> 01:32:54,219
application we then connect the user

2030
01:32:54,219 --> 01:32:56,889
facing applications which are the voting

2031
01:32:56,889 --> 01:32:59,440
app and the result app to the front-end

2032
01:32:59,440 --> 01:33:02,320
network and all the components to an

2033
01:33:02,320 --> 01:33:07,500
internal back-end network so

2034
01:33:07,500 --> 01:33:10,140
back in our docker compose file note

2035
01:33:10,140 --> 01:33:12,570
that I have actually stripped out the

2036
01:33:12,570 --> 01:33:15,570
port section for simplicity sake they're

2037
01:33:15,570 --> 01:33:17,580
still there but they're just not shown

2038
01:33:17,580 --> 01:33:20,700
here the first thing we need to do if we

2039
01:33:20,700 --> 01:33:23,040
were to use networks is to define the

2040
01:33:23,040 --> 01:33:25,680
networks we are going to use in our case

2041
01:33:25,680 --> 01:33:28,740
we have two networks front end and back

2042
01:33:28,740 --> 01:33:31,620
end so create a new property called

2043
01:33:31,620 --> 01:33:34,830
networks at the root level adjacent to

2044
01:33:34,830 --> 01:33:37,020
the services in the docker compose file

2045
01:33:37,020 --> 01:33:39,750
and add a map of networks we are

2046
01:33:39,750 --> 01:33:43,500
planning to use then under each service

2047
01:33:43,500 --> 01:33:45,990
create a network's property and provide

2048
01:33:45,990 --> 01:33:48,570
a list of networks that service must be

2049
01:33:48,570 --> 01:33:52,890
attached to in case of Redis and DB it's

2050
01:33:52,890 --> 01:33:56,010
only the back-end network in case of the

2051
01:33:56,010 --> 01:33:57,960
front-end applications such as a

2052
01:33:57,960 --> 01:34:00,600
devoting app and the result app they

2053
01:34:00,600 --> 01:34:02,780
require to be attached to both a

2054
01:34:02,780 --> 01:34:06,270
front-end and back-end Network you must

2055
01:34:06,270 --> 01:34:08,670
also add a section for worker container

2056
01:34:08,670 --> 01:34:10,860
to be added to the back-end network I

2057
01:34:10,860 --> 01:34:13,980
have just omitted that in this slide due

2058
01:34:13,980 --> 01:34:17,340
to space constraints now that you have

2059
01:34:17,340 --> 01:34:20,250
seen docker compose files head over to

2060
01:34:20,250 --> 01:34:22,170
the coding exercises and practice

2061
01:34:22,170 --> 01:34:24,770
developing some docker compose files

2062
01:34:24,770 --> 01:34:28,200
that's it for this lecture and I will

2063
01:34:28,200 --> 01:34:31,540
see you in the next lecture

2064
01:34:31,540 --> 01:34:35,409
[Music]

2065
01:34:35,409 --> 01:34:39,290
we will now look at docker registry so

2066
01:34:39,290 --> 01:34:42,590
what is a registry if the containers

2067
01:34:42,590 --> 01:34:45,860
were the rain then they would rain from

2068
01:34:45,860 --> 01:34:48,380
the docker registry which are the clouds

2069
01:34:48,380 --> 01:34:50,989
that's where docker images are stored

2070
01:34:50,989 --> 01:34:54,469
it's a central repository of all docker

2071
01:34:54,469 --> 01:34:57,380
images let's look at a simple nginx

2072
01:34:57,380 --> 01:35:00,590
container we run the docker run engine X

2073
01:35:00,590 --> 01:35:03,469
command to run an instance of the nginx

2074
01:35:03,469 --> 01:35:06,170
image let's take a closer look at that

2075
01:35:06,170 --> 01:35:09,860
image name now the name is nginx

2076
01:35:09,860 --> 01:35:12,350
but what is this image and where is this

2077
01:35:12,350 --> 01:35:15,350
image pulled from this name follows

2078
01:35:15,350 --> 01:35:18,679
Dockers image naming convention nginx

2079
01:35:18,679 --> 01:35:21,980
here is the image or the repository name

2080
01:35:21,980 --> 01:35:24,050
when you say nginx

2081
01:35:24,050 --> 01:35:27,920
it's actually nginx slash nginx the

2082
01:35:27,920 --> 01:35:30,320
first part stands for the user or

2083
01:35:30,320 --> 01:35:31,100
account name

2084
01:35:31,100 --> 01:35:34,010
so if you don't provide an account or a

2085
01:35:34,010 --> 01:35:36,469
repository name it assumes that it is

2086
01:35:36,469 --> 01:35:38,570
the same as the given name which in this

2087
01:35:38,570 --> 01:35:42,170
case is nginx the user names is usually

2088
01:35:42,170 --> 01:35:44,810
your docker hub account name or if it is

2089
01:35:44,810 --> 01:35:46,670
an organization then it's the name of

2090
01:35:46,670 --> 01:35:49,429
the organization if you were to create

2091
01:35:49,429 --> 01:35:51,830
your own account and create your own

2092
01:35:51,830 --> 01:35:54,980
repositories or images under it then you

2093
01:35:54,980 --> 01:35:58,130
would use a similar pattern now where

2094
01:35:58,130 --> 01:36:00,730
are these images stored and pulled from

2095
01:36:00,730 --> 01:36:03,620
since we have not specified the location

2096
01:36:03,620 --> 01:36:05,449
where these images are to be pulled from

2097
01:36:05,449 --> 01:36:08,750
it is assumed to be on Dockers default

2098
01:36:08,750 --> 01:36:12,140
registry docker hub the dns name for

2099
01:36:12,140 --> 01:36:15,440
which is darker dial the registry is

2100
01:36:15,440 --> 01:36:17,929
where all the images are stored whenever

2101
01:36:17,929 --> 01:36:20,270
you create a new image or update an

2102
01:36:20,270 --> 01:36:22,400
existing image you push it to the

2103
01:36:22,400 --> 01:36:24,739
registry and every time anyone deploys

2104
01:36:24,739 --> 01:36:27,380
this application it is pulled from that

2105
01:36:27,380 --> 01:36:29,780
registry there are many other popular

2106
01:36:29,780 --> 01:36:32,150
registries as well for example Google's

2107
01:36:32,150 --> 01:36:35,030
registry is at GCR that I offer a lot of

2108
01:36:35,030 --> 01:36:37,100
kubernetes related images are stored

2109
01:36:37,100 --> 01:36:39,110
like the ones used for performing

2110
01:36:39,110 --> 01:36:41,659
end-to-end tests on the cluster these

2111
01:36:41,659 --> 01:36:43,700
are all publicly accessible in

2112
01:36:43,700 --> 01:36:46,840
just that anyone can download and access

2113
01:36:46,840 --> 01:36:49,190
when you have applications built

2114
01:36:49,190 --> 01:36:50,960
in-house that shouldn't be made

2115
01:36:50,960 --> 01:36:53,150
available to the public hosting an

2116
01:36:53,150 --> 01:36:55,520
internal private registry may be a good

2117
01:36:55,520 --> 01:36:58,070
solution many cloud service providers

2118
01:36:58,070 --> 01:37:01,730
such as AWS as your GCP provide a

2119
01:37:01,730 --> 01:37:03,980
private registry by default when you

2120
01:37:03,980 --> 01:37:07,370
open an account with them on any of

2121
01:37:07,370 --> 01:37:09,650
these solutions be a docker hub or

2122
01:37:09,650 --> 01:37:11,810
Google registry or your internal private

2123
01:37:11,810 --> 01:37:14,030
registry you may choose to make a

2124
01:37:14,030 --> 01:37:16,520
repository private so that it can only

2125
01:37:16,520 --> 01:37:19,070
be accessed using a set of credentials

2126
01:37:19,070 --> 01:37:22,100
from Dockers perspective to run a

2127
01:37:22,100 --> 01:37:24,410
container using an image from a private

2128
01:37:24,410 --> 01:37:26,720
registry you first log in to your

2129
01:37:26,720 --> 01:37:29,060
private registry using the docker login

2130
01:37:29,060 --> 01:37:31,820
command input your credentials once

2131
01:37:31,820 --> 01:37:33,830
successful run the application using

2132
01:37:33,830 --> 01:37:36,080
private registry as part of the image

2133
01:37:36,080 --> 01:37:39,020
name like this now if you did not log

2134
01:37:39,020 --> 01:37:41,240
into the private registry it will come

2135
01:37:41,240 --> 01:37:43,040
back saying that the image cannot be

2136
01:37:43,040 --> 01:37:46,010
found so remember to always log in

2137
01:37:46,010 --> 01:37:48,260
before pulling or pushing to a private

2138
01:37:48,260 --> 01:37:51,710
registry we said that cloud providers

2139
01:37:51,710 --> 01:37:54,950
like AWS or GCP provide a private

2140
01:37:54,950 --> 01:37:56,630
registry when you create an account with

2141
01:37:56,630 --> 01:37:58,700
them but what if you are running your

2142
01:37:58,700 --> 01:38:01,070
application on-premise and don't have a

2143
01:38:01,070 --> 01:38:03,530
private registry how do you deploy your

2144
01:38:03,530 --> 01:38:05,510
own private registry within your

2145
01:38:05,510 --> 01:38:08,540
organization the docker registry is

2146
01:38:08,540 --> 01:38:11,120
itself another application and of course

2147
01:38:11,120 --> 01:38:13,850
is available as a docker image the name

2148
01:38:13,850 --> 01:38:16,910
of the image is registry and it exposes

2149
01:38:16,910 --> 01:38:20,690
the API on port 5,000 now that you have

2150
01:38:20,690 --> 01:38:23,210
your custom registry running at port

2151
01:38:23,210 --> 01:38:26,330
5,000 on this docker host how do you

2152
01:38:26,330 --> 01:38:30,380
push your own image to it use the docker

2153
01:38:30,380 --> 01:38:33,530
image tag command to tag the image with

2154
01:38:33,530 --> 01:38:36,140
a private registry URL in it in this

2155
01:38:36,140 --> 01:38:38,330
case since it's running on the same door

2156
01:38:38,330 --> 01:38:40,730
host I can use localhost

2157
01:38:40,730 --> 01:38:44,000
semi colon 5,000 followed by the image

2158
01:38:44,000 --> 01:38:47,120
name I can then push my image to my

2159
01:38:47,120 --> 01:38:49,400
local private registry using the command

2160
01:38:49,400 --> 01:38:51,980
docker push and the new image name with

2161
01:38:51,980 --> 01:38:53,810
the docker registry information in it

2162
01:38:53,810 --> 01:38:56,540
from there on I can pull my image from

2163
01:38:56,540 --> 01:38:57,200
anywhere

2164
01:38:57,200 --> 01:38:58,760
within this network using either

2165
01:38:58,760 --> 01:39:01,070
localhost if you're on the same host or

2166
01:39:01,070 --> 01:39:04,340
the IP or domain name of my docker host

2167
01:39:04,340 --> 01:39:07,340
if I'm accessing from another host in my

2168
01:39:07,340 --> 01:39:10,070
environment well let's sit for this

2169
01:39:10,070 --> 01:39:10,610
lecture

2170
01:39:10,610 --> 01:39:12,290
hello words of the practice test and

2171
01:39:12,290 --> 01:39:15,320
practice working with private docker

2172
01:39:15,320 --> 01:39:21,260
registries welcome to this lecture on

2173
01:39:21,260 --> 01:39:23,720
docker engine in this lecture we will

2174
01:39:23,720 --> 01:39:25,880
take a deeper look at Dockers

2175
01:39:25,880 --> 01:39:28,190
architecture how it actually runs

2176
01:39:28,190 --> 01:39:30,560
applications in isolated containers and

2177
01:39:30,560 --> 01:39:34,790
how it works under the hood docker

2178
01:39:34,790 --> 01:39:36,860
engine as we have learned before is

2179
01:39:36,860 --> 01:39:39,260
simply referred to a host with docker

2180
01:39:39,260 --> 01:39:41,930
installed on it when you install docker

2181
01:39:41,930 --> 01:39:44,030
on a Linux host you're actually

2182
01:39:44,030 --> 01:39:46,220
installing three different components

2183
01:39:46,220 --> 01:39:49,340
the docker daemon the rest api server

2184
01:39:49,340 --> 01:39:52,850
and the docker CLI the docker daemon is

2185
01:39:52,850 --> 01:39:55,340
a background process that manages docker

2186
01:39:55,340 --> 01:39:58,130
objects such as the images containers

2187
01:39:58,130 --> 01:40:01,340
volumes and networks the docker rest api

2188
01:40:01,340 --> 01:40:03,890
server is the api interface that

2189
01:40:03,890 --> 01:40:06,170
programs can use to talk to the daemon

2190
01:40:06,170 --> 01:40:08,390
and provide instructions you could

2191
01:40:08,390 --> 01:40:10,580
create your own tools using this REST

2192
01:40:10,580 --> 01:40:13,700
API and the docker CLI is nothing but

2193
01:40:13,700 --> 01:40:15,890
the command-line interface that we've

2194
01:40:15,890 --> 01:40:18,590
been using until now to perform actions

2195
01:40:18,590 --> 01:40:20,720
such as running a container stopping

2196
01:40:20,720 --> 01:40:24,650
containers destroying images etc it uses

2197
01:40:24,650 --> 01:40:27,290
the REST API to interact with the docker

2198
01:40:27,290 --> 01:40:31,130
demon something to note here is that the

2199
01:40:31,130 --> 01:40:34,190
docker CLI need not necessarily be on

2200
01:40:34,190 --> 01:40:36,590
the same host it could be on another

2201
01:40:36,590 --> 01:40:40,160
system like a laptop and can still work

2202
01:40:40,160 --> 01:40:43,700
with a remote docker engine simply use

2203
01:40:43,700 --> 01:40:46,490
the dash H option on the docker command

2204
01:40:46,490 --> 01:40:49,850
and specify the remote docker engine

2205
01:40:49,850 --> 01:40:52,820
address and a port as shown here for

2206
01:40:52,820 --> 01:40:56,300
example to run a container based on ng I

2207
01:40:56,300 --> 01:40:59,180
and X on a remote docker host run the

2208
01:40:59,180 --> 01:41:03,980
command docker dash H equals 10.1 23

2209
01:41:03,980 --> 01:41:11,440
2000 call n' to 375 run ngan

2210
01:41:14,250 --> 01:41:17,290
now let's try and understand how exactly

2211
01:41:17,290 --> 01:41:20,010
our applications containerized in docker

2212
01:41:20,010 --> 01:41:21,700
how does it work

2213
01:41:21,700 --> 01:41:25,120
under the hood docker uses namespaces to

2214
01:41:25,120 --> 01:41:28,810
isolate workspace process IDs network

2215
01:41:28,810 --> 01:41:31,930
inter-process communication mounds and

2216
01:41:31,930 --> 01:41:35,020
unix time sharing systems are created in

2217
01:41:35,020 --> 01:41:37,660
their own namespace thereby providing

2218
01:41:37,660 --> 01:41:43,150
isolation between containers let's take

2219
01:41:43,150 --> 01:41:45,400
a look at one of the namespace isolation

2220
01:41:45,400 --> 01:41:48,880
technique process ID namespaces whenever

2221
01:41:48,880 --> 01:41:51,490
a Linux system boots up it starts with

2222
01:41:51,490 --> 01:41:53,890
just one process with a process ID of

2223
01:41:53,890 --> 01:41:56,680
one this is the root process and kicks

2224
01:41:56,680 --> 01:41:58,780
off all the other processes in the

2225
01:41:58,780 --> 01:42:01,450
system by the time the system boots up

2226
01:42:01,450 --> 01:42:03,580
completely we have a handful of

2227
01:42:03,580 --> 01:42:06,670
processors running this can be seen by

2228
01:42:06,670 --> 01:42:09,340
running the PS command to list all the

2229
01:42:09,340 --> 01:42:12,640
running processes the process IDs are

2230
01:42:12,640 --> 01:42:15,790
unique and two processes cannot have the

2231
01:42:15,790 --> 01:42:19,360
same process ID now if we were to create

2232
01:42:19,360 --> 01:42:21,820
a container which is basically like a

2233
01:42:21,820 --> 01:42:23,800
child system within the current system

2234
01:42:23,800 --> 01:42:27,430
the child system needs to think that it

2235
01:42:27,430 --> 01:42:29,650
is an independent system on its own and

2236
01:42:29,650 --> 01:42:32,220
it has its own set of processes

2237
01:42:32,220 --> 01:42:35,020
originating from a root process with a

2238
01:42:35,020 --> 01:42:39,190
process ID of one but we know that there

2239
01:42:39,190 --> 01:42:41,200
is no hard isolation between the

2240
01:42:41,200 --> 01:42:43,540
containers and the underlying host so

2241
01:42:43,540 --> 01:42:45,160
the processes running inside the

2242
01:42:45,160 --> 01:42:47,710
container or in fact processes running

2243
01:42:47,710 --> 01:42:49,780
on the underlying host and so two

2244
01:42:49,780 --> 01:42:52,150
processes cannot have the same process

2245
01:42:52,150 --> 01:42:55,570
ID of one this is where namespaces come

2246
01:42:55,570 --> 01:42:58,270
in to play with process ID namespaces

2247
01:42:58,270 --> 01:43:00,460
each process can have multiple process

2248
01:43:00,460 --> 01:43:03,370
IDs associated with it for example when

2249
01:43:03,370 --> 01:43:05,110
the processes start in the container

2250
01:43:05,110 --> 01:43:07,030
it's actually just another set of

2251
01:43:07,030 --> 01:43:09,370
processes on the base Linux system and

2252
01:43:09,370 --> 01:43:12,010
it gets the next available process ID in

2253
01:43:12,010 --> 01:43:15,700
this case 5 & 6 however they also get

2254
01:43:15,700 --> 01:43:18,400
another process ID starting with PID 1

2255
01:43:18,400 --> 01:43:20,620
in the container name space which is

2256
01:43:20,620 --> 01:43:23,540
only visible inside the container so the

2257
01:43:23,540 --> 01:43:25,490
container things that it has its own

2258
01:43:25,490 --> 01:43:28,250
route process tree and so it is an

2259
01:43:28,250 --> 01:43:31,040
independent system so how does that

2260
01:43:31,040 --> 01:43:33,920
relate to an actual system how do you

2261
01:43:33,920 --> 01:43:36,560
see this on a host let's say I were to

2262
01:43:36,560 --> 01:43:39,290
run an ng I in X Server as a container

2263
01:43:39,290 --> 01:43:42,080
we know that the nginx container

2264
01:43:42,080 --> 01:43:45,410
runs an NGO next service if we were to

2265
01:43:45,410 --> 01:43:47,690
list all the services inside the docker

2266
01:43:47,690 --> 01:43:50,510
container we see that the ng ionic

2267
01:43:50,510 --> 01:43:53,180
service running with a process ID of one

2268
01:43:53,180 --> 01:43:56,210
this is the process ID of the service

2269
01:43:56,210 --> 01:43:59,570
inside of the container namespace if we

2270
01:43:59,570 --> 01:44:02,420
list the services on the docker host we

2271
01:44:02,420 --> 01:44:04,400
will see the same service but with a

2272
01:44:04,400 --> 01:44:08,120
different process ID that indicates that

2273
01:44:08,120 --> 01:44:11,090
all processes are in fact running on the

2274
01:44:11,090 --> 01:44:13,850
same host but separated into their own

2275
01:44:13,850 --> 01:44:19,190
containers using namespaces so we

2276
01:44:19,190 --> 01:44:21,320
learned that the underlying docker host

2277
01:44:21,320 --> 01:44:24,020
as well as the containers share the same

2278
01:44:24,020 --> 01:44:27,520
system resources such as CPU and memory

2279
01:44:27,520 --> 01:44:30,140
how much of the resources are dedicated

2280
01:44:30,140 --> 01:44:32,960
to the host and the containers and how

2281
01:44:32,960 --> 01:44:34,880
does docker manage and share the

2282
01:44:34,880 --> 01:44:37,850
resources between the containers by

2283
01:44:37,850 --> 01:44:40,160
default there is no restriction as to

2284
01:44:40,160 --> 01:44:42,560
how much of a resource a container can

2285
01:44:42,560 --> 01:44:45,830
use and hence a container may end up

2286
01:44:45,830 --> 01:44:48,260
utilizing all of the resources on the

2287
01:44:48,260 --> 01:44:50,810
underlying host but there is a way to

2288
01:44:50,810 --> 01:44:53,630
restrict the amount of CPU or memory a

2289
01:44:53,630 --> 01:44:57,020
container can use docker uses three

2290
01:44:57,020 --> 01:44:59,600
groups or control groups to restrict the

2291
01:44:59,600 --> 01:45:02,240
amount of hardware resources allocated

2292
01:45:02,240 --> 01:45:05,720
to each container this can be done by

2293
01:45:05,720 --> 01:45:09,260
providing the - - CPUs option to the

2294
01:45:09,260 --> 01:45:11,840
docker run command providing a value of

2295
01:45:11,840 --> 01:45:14,810
0.5 will ensure that the container does

2296
01:45:14,810 --> 01:45:17,810
not take up more than 50% of the host

2297
01:45:17,810 --> 01:45:21,410
CPU at any given time the same goes with

2298
01:45:21,410 --> 01:45:24,500
memory setting a value of hundred M to

2299
01:45:24,500 --> 01:45:27,350
the - - memory option limits the amount

2300
01:45:27,350 --> 01:45:29,900
of memory the container can use to a

2301
01:45:29,900 --> 01:45:33,200
hundred megabytes if you are interested

2302
01:45:33,200 --> 01:45:35,870
in reading more on this topic refer to

2303
01:45:35,870 --> 01:45:37,560
the links I posted in

2304
01:45:37,560 --> 01:45:40,080
the reference page that's it for now on

2305
01:45:40,080 --> 01:45:48,180
docker engine earlier in this course we

2306
01:45:48,180 --> 01:45:50,130
learned that containers share the

2307
01:45:50,130 --> 01:45:52,530
underlying OS kernel and as a result we

2308
01:45:52,530 --> 01:45:54,870
cannot have a Windows container running

2309
01:45:54,870 --> 01:45:57,810
on Linux host or vice versa we need to

2310
01:45:57,810 --> 01:45:59,400
keep this in mind while going through

2311
01:45:59,400 --> 01:46:01,650
this lecture as it's very important

2312
01:46:01,650 --> 01:46:03,960
concept and most beginners tend to have

2313
01:46:03,960 --> 01:46:06,780
an issue with it so what are the options

2314
01:46:06,780 --> 01:46:10,200
available for docker on Windows there

2315
01:46:10,200 --> 01:46:11,550
are two options available

2316
01:46:11,550 --> 01:46:13,920
the first one is dock or on Windows

2317
01:46:13,920 --> 01:46:16,950
using docker toolbox and the second one

2318
01:46:16,950 --> 01:46:19,800
is the docker desktop for Windows option

2319
01:46:19,800 --> 01:46:22,950
we will look at each of these now let's

2320
01:46:22,950 --> 01:46:24,900
take a look at the first option docker

2321
01:46:24,900 --> 01:46:28,110
toolbox this was the original support

2322
01:46:28,110 --> 01:46:31,200
for docker on Windows imagine that you

2323
01:46:31,200 --> 01:46:33,600
have a Windows laptop and no access to

2324
01:46:33,600 --> 01:46:36,000
any Linux system whatsoever but you

2325
01:46:36,000 --> 01:46:38,430
would like to try docker you don't have

2326
01:46:38,430 --> 01:46:40,620
access to a Linux system in the lab or

2327
01:46:40,620 --> 01:46:43,800
in the cloud what would you do what I

2328
01:46:43,800 --> 01:46:45,750
did was to install a virtualization

2329
01:46:45,750 --> 01:46:47,460
software on my Windows system like

2330
01:46:47,460 --> 01:46:49,350
Oracle VirtualBox or VMware Workstation

2331
01:46:49,350 --> 01:46:52,380
and deploy a Linux VM on it such as

2332
01:46:52,380 --> 01:46:55,800
Ubuntu or Debian then install docker on

2333
01:46:55,800 --> 01:46:58,080
the Linux VM and then play around with

2334
01:46:58,080 --> 01:47:02,310
it this is what the first option really

2335
01:47:02,310 --> 01:47:04,410
does it doesn't really have anything

2336
01:47:04,410 --> 01:47:06,780
much to do with Windows you cannot

2337
01:47:06,780 --> 01:47:09,480
create Windows based docker images or

2338
01:47:09,480 --> 01:47:11,880
run Windows based docker containers you

2339
01:47:11,880 --> 01:47:13,920
obviously cannot run Linux container

2340
01:47:13,920 --> 01:47:16,650
directly on Windows either you're just

2341
01:47:16,650 --> 01:47:19,050
working with docker on a Linux virtual

2342
01:47:19,050 --> 01:47:22,260
machine on a Windows host docker

2343
01:47:22,260 --> 01:47:24,390
however provides us with a set of tools

2344
01:47:24,390 --> 01:47:26,730
to make this easy which is called as the

2345
01:47:26,730 --> 01:47:29,880
docker toolbox the docker toolbox

2346
01:47:29,880 --> 01:47:32,310
contains a set of tools like Oracle

2347
01:47:32,310 --> 01:47:35,010
VirtualBox docker engine docker machine

2348
01:47:35,010 --> 01:47:37,110
docker compose and a user interface

2349
01:47:37,110 --> 01:47:39,900
called CAD Matic this will help you get

2350
01:47:39,900 --> 01:47:41,790
started by simply downloading and

2351
01:47:41,790 --> 01:47:44,040
running the docker toolbox executable I

2352
01:47:44,040 --> 01:47:46,800
will install virtualbox deploy a

2353
01:47:46,800 --> 01:47:49,290
lightweight VM called boot to docker

2354
01:47:49,290 --> 01:47:50,929
which has docker

2355
01:47:50,929 --> 01:47:53,239
it already so that you are all set to

2356
01:47:53,239 --> 01:47:55,519
start with docker easily and with within

2357
01:47:55,519 --> 01:47:56,709
a short period of time

2358
01:47:56,709 --> 01:47:59,630
now what about requirements you must

2359
01:47:59,630 --> 01:48:01,550
ensure that your operating system is

2360
01:48:01,550 --> 01:48:04,999
64-bit Windows 7 or higher and that the

2361
01:48:04,999 --> 01:48:07,159
virtualization is enabled on the system

2362
01:48:07,159 --> 01:48:10,309
now remember docker to box is a legacy

2363
01:48:10,309 --> 01:48:12,739
solution for older Windows systems that

2364
01:48:12,739 --> 01:48:14,869
do not meet requirements for the newer

2365
01:48:14,869 --> 01:48:18,800
docker for Windows option the second

2366
01:48:18,800 --> 01:48:21,349
option is the NewYork an option called

2367
01:48:21,349 --> 01:48:23,719
docker Desktop for Windows in the

2368
01:48:23,719 --> 01:48:25,189
previous option we saw that we had

2369
01:48:25,189 --> 01:48:27,889
Oracle VirtualBox installed on Windows

2370
01:48:27,889 --> 01:48:30,349
and then a Linux system and then docker

2371
01:48:30,349 --> 01:48:33,469
on that Linux system now with docker for

2372
01:48:33,469 --> 01:48:35,300
Windows we take out Oracle VirtualBox

2373
01:48:35,300 --> 01:48:36,979
and use the native virtualization

2374
01:48:36,979 --> 01:48:39,199
technology available with Windows called

2375
01:48:39,199 --> 01:48:41,599
Microsoft hyper-v during the

2376
01:48:41,599 --> 01:48:43,189
installation process for docker for

2377
01:48:43,189 --> 01:48:45,079
Windows it will still automatically

2378
01:48:45,079 --> 01:48:47,239
create a Linux system underneath but

2379
01:48:47,239 --> 01:48:49,400
this time it is created on the Microsoft

2380
01:48:49,400 --> 01:48:52,219
hyper-v instead of Oracle VirtualBox and

2381
01:48:52,219 --> 01:48:53,920
have docker running on that system

2382
01:48:53,920 --> 01:48:56,599
because of this dependency on hyper-v

2383
01:48:56,599 --> 01:48:58,550
this option is only supported for

2384
01:48:58,550 --> 01:49:00,829
Windows 10 enterprise or professional

2385
01:49:00,829 --> 01:49:03,429
Edition and on Windows Server 2016

2386
01:49:03,429 --> 01:49:05,659
because both these operating systems

2387
01:49:05,659 --> 01:49:08,959
come with hyper-v support by default now

2388
01:49:08,959 --> 01:49:11,689
here is the most important point so far

2389
01:49:11,689 --> 01:49:14,300
whatever we have been discussing with

2390
01:49:14,300 --> 01:49:16,639
Dockers support for Windows it is

2391
01:49:16,639 --> 01:49:19,219
strictly for Linux containers Linux

2392
01:49:19,219 --> 01:49:21,769
applications packaged into Linux docker

2393
01:49:21,769 --> 01:49:24,110
images we're not talking about Windows

2394
01:49:24,110 --> 01:49:25,999
applications or Windows images or

2395
01:49:25,999 --> 01:49:28,550
Windows containers both the options we

2396
01:49:28,550 --> 01:49:31,309
just discussed will help you run a Linux

2397
01:49:31,309 --> 01:49:35,030
container on a Windows host with Windows

2398
01:49:35,030 --> 01:49:38,599
Server 2016 Microsoft announced support

2399
01:49:38,599 --> 01:49:40,340
for Windows containers for the first

2400
01:49:40,340 --> 01:49:42,979
time you can now packaged applications

2401
01:49:42,979 --> 01:49:45,289
Windows applications into Windows docker

2402
01:49:45,289 --> 01:49:47,570
containers and run them on Windows

2403
01:49:47,570 --> 01:49:49,909
chopper host using docker desktop for

2404
01:49:49,909 --> 01:49:52,939
Windows when you install docker desktop

2405
01:49:52,939 --> 01:49:55,579
for Windows the default option is to

2406
01:49:55,579 --> 01:49:58,519
work with Linux containers but if you

2407
01:49:58,519 --> 01:50:00,199
would like to run Windows containers

2408
01:50:00,199 --> 01:50:02,959
then you must explicitly configure

2409
01:50:02,959 --> 01:50:04,080
docker

2410
01:50:04,080 --> 01:50:06,390
windows to switch to using windows

2411
01:50:06,390 --> 01:50:09,930
containers in early 2016

2412
01:50:09,930 --> 01:50:12,210
Microsoft announced windows containers

2413
01:50:12,210 --> 01:50:14,490
then you could create Windows based

2414
01:50:14,490 --> 01:50:16,560
images and run Windows containers on a

2415
01:50:16,560 --> 01:50:18,120
Windows server just like how you would

2416
01:50:18,120 --> 01:50:20,840
run Linux containers on a Linux system

2417
01:50:20,840 --> 01:50:23,640
now you can create windows images

2418
01:50:23,640 --> 01:50:25,830
container as your applications and share

2419
01:50:25,830 --> 01:50:28,370
them through the docker store as well

2420
01:50:28,370 --> 01:50:31,440
unlike in Linux there are two types of

2421
01:50:31,440 --> 01:50:34,470
containers in Windows the first one is a

2422
01:50:34,470 --> 01:50:36,540
Windows Server container which works

2423
01:50:36,540 --> 01:50:38,850
exactly like Linux containers where the

2424
01:50:38,850 --> 01:50:41,130
OS kernel is shared with the underlying

2425
01:50:41,130 --> 01:50:43,410
operating system to allow better

2426
01:50:43,410 --> 01:50:45,600
security boundary between containers and

2427
01:50:45,600 --> 01:50:47,100
to a lot of kernels with different

2428
01:50:47,100 --> 01:50:49,440
versions and configurations to coexist

2429
01:50:49,440 --> 01:50:52,080
the second option was introduced known

2430
01:50:52,080 --> 01:50:55,080
as the hyper-v isolation with hyper-v

2431
01:50:55,080 --> 01:50:58,530
isolation each container is run within a

2432
01:50:58,530 --> 01:51:00,570
highly optimized virtual machine

2433
01:51:00,570 --> 01:51:03,030
guaranteeing complete kernel isolation

2434
01:51:03,030 --> 01:51:04,440
between the containers and the

2435
01:51:04,440 --> 01:51:07,170
underlying host now while in the Linux

2436
01:51:07,170 --> 01:51:09,690
world you had a number of base images

2437
01:51:09,690 --> 01:51:11,880
for a Linux system such as ubuntu debian

2438
01:51:11,880 --> 01:51:14,910
fedora alpine etc if you remember that

2439
01:51:14,910 --> 01:51:17,430
that is what you specify the beginning

2440
01:51:17,430 --> 01:51:19,560
of the docker file in the windows world

2441
01:51:19,560 --> 01:51:22,050
we have two options the Windows server

2442
01:51:22,050 --> 01:51:26,220
core and nano server a nano server is a

2443
01:51:26,220 --> 01:51:28,290
headless deployment option for Windows

2444
01:51:28,290 --> 01:51:30,600
Server which runs at a fraction of size

2445
01:51:30,600 --> 01:51:33,090
of the full operating system you can

2446
01:51:33,090 --> 01:51:35,070
think of this like the Alpine image in

2447
01:51:35,070 --> 01:51:38,310
Linux the windows server core though is

2448
01:51:38,310 --> 01:51:40,560
not as lightweight as you might expect

2449
01:51:40,560 --> 01:51:44,430
it to be finally Windows containers are

2450
01:51:44,430 --> 01:51:47,340
supported on Windows Server 2016 nano

2451
01:51:47,340 --> 01:51:49,740
server and windows 10 professional and

2452
01:51:49,740 --> 01:51:52,560
Enterprise Edition remember on Windows

2453
01:51:52,560 --> 01:51:54,840
10 professional and Enterprise Edition

2454
01:51:54,840 --> 01:51:57,510
only supports hyper-v isolated

2455
01:51:57,510 --> 01:51:59,970
containers meaning as we just discussed

2456
01:51:59,970 --> 01:52:02,940
every container deployed is deployed on

2457
01:52:02,940 --> 01:52:06,090
a highly optimized virtual machine well

2458
01:52:06,090 --> 01:52:09,660
that's it about docker on windows now

2459
01:52:09,660 --> 01:52:11,790
before I finish I want to point out one

2460
01:52:11,790 --> 01:52:14,910
important fact we saw two ways of

2461
01:52:14,910 --> 01:52:16,320
running a docker container using

2462
01:52:16,320 --> 01:52:17,760
VirtualBox or hyper

2463
01:52:17,760 --> 01:52:20,130
but remember VirtualBox and hyper-v

2464
01:52:20,130 --> 01:52:22,350
cannot coexist on the same Windows host

2465
01:52:22,350 --> 01:52:24,450
so if you started off with docker

2466
01:52:24,450 --> 01:52:26,430
toolbox with VirtualBox and if you plan

2467
01:52:26,430 --> 01:52:29,130
to migrate to hyper-v remember you

2468
01:52:29,130 --> 01:52:30,810
cannot have both solutions at the same

2469
01:52:30,810 --> 01:52:32,430
time there is a migration and guide

2470
01:52:32,430 --> 01:52:34,500
available on docker documentation page

2471
01:52:34,500 --> 01:52:37,350
on how to migrate from Marshall box to

2472
01:52:37,350 --> 01:52:40,110
hyper wait that's it for now thank you

2473
01:52:40,110 --> 01:52:42,240
and I will see you in the next lecture

2474
01:52:42,240 --> 01:52:45,620
[Music]

2475
01:52:45,620 --> 01:52:49,410
we now look at docker on Mac docker on

2476
01:52:49,410 --> 01:52:51,660
Mac is similar to docker on Windows

2477
01:52:51,660 --> 01:52:54,060
there are two options to get started

2478
01:52:54,060 --> 01:52:56,520
docker on Mac using docker toolbox or

2479
01:52:56,520 --> 01:53:00,090
docker Desktop for Mac option let's look

2480
01:53:00,090 --> 01:53:03,330
at the first option docker toolbox this

2481
01:53:03,330 --> 01:53:05,670
was the original support for docker on

2482
01:53:05,670 --> 01:53:08,970
Mac it is darker on a Linux VM created

2483
01:53:08,970 --> 01:53:12,120
using VirtualBox on Mac as with Windows

2484
01:53:12,120 --> 01:53:13,470
it has nothing to do with Mac

2485
01:53:13,470 --> 01:53:15,810
applications or Mac based images or Mac

2486
01:53:15,810 --> 01:53:18,090
containers it purely runs Linux

2487
01:53:18,090 --> 01:53:21,480
containers on a Mac OS dollar toolbox

2488
01:53:21,480 --> 01:53:23,610
contains a set of tools like Oracle

2489
01:53:23,610 --> 01:53:25,650
VirtualBox docker and Jane docker

2490
01:53:25,650 --> 01:53:27,630
machine docker compose and a user

2491
01:53:27,630 --> 01:53:29,880
interface called CAD Matic when you

2492
01:53:29,880 --> 01:53:31,920
download and install the docker toolbox

2493
01:53:31,920 --> 01:53:34,080
executable it installs

2494
01:53:34,080 --> 01:53:36,570
VirtualBox deploys lightweight VM called

2495
01:53:36,570 --> 01:53:38,340
boot a docker which has darker running

2496
01:53:38,340 --> 01:53:39,060
in it already

2497
01:53:39,060 --> 01:53:45,060
this requires Mac OS 10.8 or newer the

2498
01:53:45,060 --> 01:53:47,190
second option is the newer option called

2499
01:53:47,190 --> 01:53:49,980
docker Desktop for Mac with docker

2500
01:53:49,980 --> 01:53:52,320
Desktop for Mac we take out or

2501
01:53:52,320 --> 01:53:54,600
commercial box and use hyper cat

2502
01:53:54,600 --> 01:53:57,239
virtualization technology during the

2503
01:53:57,239 --> 01:53:59,550
installation process for docker for Mac

2504
01:53:59,550 --> 01:54:02,040
it will still automatically create a

2505
01:54:02,040 --> 01:54:04,620
Linux system underneath but this time it

2506
01:54:04,620 --> 01:54:06,600
is created on hyper kit instead of

2507
01:54:06,600 --> 01:54:08,550
Oracle VirtualBox and have docker

2508
01:54:08,550 --> 01:54:10,470
running on that system

2509
01:54:10,470 --> 01:54:14,880
this requires Mac OS Sierra 10.12 or

2510
01:54:14,880 --> 01:54:17,520
newer and Martin and the Mac hardware

2511
01:54:17,520 --> 01:54:21,030
must be 2010 or newer model finally

2512
01:54:21,030 --> 01:54:23,460
remember that all of this is to be able

2513
01:54:23,460 --> 01:54:26,640
to run the Linux container on Mac as of

2514
01:54:26,640 --> 01:54:28,380
this recording there are no Mac based

2515
01:54:28,380 --> 01:54:31,580
images or containers well that

2516
01:54:31,580 --> 01:54:39,650
with docker on Mac for now we will now

2517
01:54:39,650 --> 01:54:41,560
try to understand what container

2518
01:54:41,560 --> 01:54:44,780
orchestration is so far in this course

2519
01:54:44,780 --> 01:54:47,690
we've seen that with docker you can run

2520
01:54:47,690 --> 01:54:49,250
a single instance of the application

2521
01:54:49,250 --> 01:54:52,760
with a simple docker run command in this

2522
01:54:52,760 --> 01:54:55,670
case to run a node.js based application

2523
01:54:55,670 --> 01:54:58,040
you're on the docker run nodejs command

2524
01:54:58,040 --> 01:55:00,650
but that's just one instance of your

2525
01:55:00,650 --> 01:55:03,140
application on one docker host what

2526
01:55:03,140 --> 01:55:04,910
happens when the number of users

2527
01:55:04,910 --> 01:55:07,760
increase and that instance is no longer

2528
01:55:07,760 --> 01:55:10,070
able to handle the load you deploy

2529
01:55:10,070 --> 01:55:12,200
additional instance of your application

2530
01:55:12,200 --> 01:55:13,910
by running the docker run command

2531
01:55:13,910 --> 01:55:16,430
multiple times so that's something you

2532
01:55:16,430 --> 01:55:18,590
have to do yourself you have to keep a

2533
01:55:18,590 --> 01:55:20,030
close watch on the load and performance

2534
01:55:20,030 --> 01:55:21,650
of your application and deploy

2535
01:55:21,650 --> 01:55:24,590
additional instances yourself and not

2536
01:55:24,590 --> 01:55:26,660
just that you have to keep a close watch

2537
01:55:26,660 --> 01:55:28,730
on the health of these applications and

2538
01:55:28,730 --> 01:55:32,120
if a container was to fail you should be

2539
01:55:32,120 --> 01:55:34,040
able to detect that and run the docker

2540
01:55:34,040 --> 01:55:36,110
run command again to deploy another

2541
01:55:36,110 --> 01:55:38,870
instance of that application what about

2542
01:55:38,870 --> 01:55:40,910
the health of the docker host itself

2543
01:55:40,910 --> 01:55:43,340
what if the host crashes and is

2544
01:55:43,340 --> 01:55:46,310
inaccessible the containers hosted on

2545
01:55:46,310 --> 01:55:49,730
that host become inaccessible too so

2546
01:55:49,730 --> 01:55:51,860
what do you do in order to solve these

2547
01:55:51,860 --> 01:55:54,220
issues you will need a dedicated

2548
01:55:54,220 --> 01:55:56,990
engineer who can sit and monitor the

2549
01:55:56,990 --> 01:55:59,420
state performance and health of the

2550
01:55:59,420 --> 01:56:01,430
containers and take necessary actions to

2551
01:56:01,430 --> 01:56:03,680
remediate the situation but when you

2552
01:56:03,680 --> 01:56:05,540
have large applications deployed with

2553
01:56:05,540 --> 01:56:07,850
tens of thousands of containers that's

2554
01:56:07,850 --> 01:56:10,340
that's not a practical approach so you

2555
01:56:10,340 --> 01:56:13,880
can build your own scripts and and that

2556
01:56:13,880 --> 01:56:16,550
will help you tackle these issues to

2557
01:56:16,550 --> 01:56:20,150
some extent container orchestration is

2558
01:56:20,150 --> 01:56:22,550
just a solution for that it is a

2559
01:56:22,550 --> 01:56:25,340
solution that consists of a set of tools

2560
01:56:25,340 --> 01:56:27,470
and scripts that can help host

2561
01:56:27,470 --> 01:56:30,010
containers in a production environment

2562
01:56:30,010 --> 01:56:32,450
typically a container orchestration

2563
01:56:32,450 --> 01:56:34,880
solution consists of multiple docker

2564
01:56:34,880 --> 01:56:37,820
hosts that can host containers that way

2565
01:56:37,820 --> 01:56:40,250
even if one fails the application is

2566
01:56:40,250 --> 01:56:43,040
still accessible through the others the

2567
01:56:43,040 --> 01:56:45,320
container orchestration solution is

2568
01:56:45,320 --> 01:56:47,810
allows you to deploy hundreds or

2569
01:56:47,810 --> 01:56:49,670
thousands of instances of your

2570
01:56:49,670 --> 01:56:52,700
application with a single command this

2571
01:56:52,700 --> 01:56:55,940
is a command used for docker swarm we'll

2572
01:56:55,940 --> 01:56:58,190
look at the command itself in a bit

2573
01:56:58,190 --> 01:57:00,230
some orchestration solutions can help

2574
01:57:00,230 --> 01:57:03,020
you automatically scale up the number of

2575
01:57:03,020 --> 01:57:05,690
instances when users increase and scale

2576
01:57:05,690 --> 01:57:07,460
down the number of instances when the

2577
01:57:07,460 --> 01:57:10,850
demand decreases some solutions can even

2578
01:57:10,850 --> 01:57:12,740
help you in automatically adding

2579
01:57:12,740 --> 01:57:14,870
additional hosts to support the user

2580
01:57:14,870 --> 01:57:17,390
load and not just clustering and scaling

2581
01:57:17,390 --> 01:57:19,550
the container orchestration solutions

2582
01:57:19,550 --> 01:57:21,800
also provide support for advanced

2583
01:57:21,800 --> 01:57:23,600
networking between these containers

2584
01:57:23,600 --> 01:57:26,600
across different hosts as well as load

2585
01:57:26,600 --> 01:57:28,880
balancing user requests across different

2586
01:57:28,880 --> 01:57:30,500
house they also provide support for

2587
01:57:30,500 --> 01:57:32,750
sharing storage between the house as

2588
01:57:32,750 --> 01:57:34,430
well as support for configuration

2589
01:57:34,430 --> 01:57:36,290
management and security within the

2590
01:57:36,290 --> 01:57:38,840
cluster there are multiple container

2591
01:57:38,840 --> 01:57:40,850
orchestration solutions available today

2592
01:57:40,850 --> 01:57:44,570
docker has docker swamp kubernetes from

2593
01:57:44,570 --> 01:57:48,230
Google and mezzo mezz from Paget while

2594
01:57:48,230 --> 01:57:50,450
docker swamp is really easy to set up

2595
01:57:50,450 --> 01:57:52,610
and get started it lacks some of the

2596
01:57:52,610 --> 01:57:54,680
advanced auto scaling features required

2597
01:57:54,680 --> 01:57:56,420
for complex production grade

2598
01:57:56,420 --> 01:57:59,870
applications mezzos on the other hand is

2599
01:57:59,870 --> 01:58:01,700
quite difficult to set up and get

2600
01:58:01,700 --> 01:58:02,060
started

2601
01:58:02,060 --> 01:58:04,690
but supports many advanced features

2602
01:58:04,690 --> 01:58:08,000
kubernetes arguably the most popular of

2603
01:58:08,000 --> 01:58:10,220
it all is a bit difficult to set up and

2604
01:58:10,220 --> 01:58:12,140
get started but provides a lot of

2605
01:58:12,140 --> 01:58:15,230
options to customize deployments and has

2606
01:58:15,230 --> 01:58:17,710
support for many different vendors

2607
01:58:17,710 --> 01:58:20,270
kubernetes is now supported on all

2608
01:58:20,270 --> 01:58:22,940
public cloud service providers like GCP

2609
01:58:22,940 --> 01:58:26,120
azure and AWS and the kubernetes project

2610
01:58:26,120 --> 01:58:28,460
is one of the top-ranked projects on

2611
01:58:28,460 --> 01:58:31,700
github in upcoming lectures we will take

2612
01:58:31,700 --> 01:58:33,920
a quick look at docker swamp and

2613
01:58:33,920 --> 01:58:35,470
kubernetes

2614
01:58:35,470 --> 01:58:39,460
[Music]

2615
01:58:39,460 --> 01:58:42,410
we will now get a quick introduction to

2616
01:58:42,410 --> 01:58:46,070
docker swarm docker swarm has a lot of

2617
01:58:46,070 --> 01:58:48,500
concepts to cover and requires its own

2618
01:58:48,500 --> 01:58:51,380
course but we will try to take a quick

2619
01:58:51,380 --> 01:58:53,330
look at some of the basic details so you

2620
01:58:53,330 --> 01:58:56,750
can get a brief idea on what it is with

2621
01:58:56,750 --> 01:58:58,820
docker swarm you could now combine

2622
01:58:58,820 --> 01:59:01,280
multiple docker machines together into a

2623
01:59:01,280 --> 01:59:03,830
single cluster docker swarm will take

2624
01:59:03,830 --> 01:59:05,780
care of distributing your services or

2625
01:59:05,780 --> 01:59:08,719
your application instances into separate

2626
01:59:08,719 --> 01:59:11,450
hosts for high availability and for load

2627
01:59:11,450 --> 01:59:13,969
balancing across different systems and

2628
01:59:13,969 --> 01:59:16,700
hardware to set up a docker swamp you

2629
01:59:16,700 --> 01:59:19,219
must first have hosts or multiple hosts

2630
01:59:19,219 --> 01:59:21,410
with docker installed on them then you

2631
01:59:21,410 --> 01:59:23,780
must designate one host to be the

2632
01:59:23,780 --> 01:59:26,750
manager or the master or the swamp

2633
01:59:26,750 --> 01:59:29,090
manager as it is called and others as

2634
01:59:29,090 --> 01:59:31,760
slaves or workers once you're done with

2635
01:59:31,760 --> 01:59:33,680
that run the docker swarm init command

2636
01:59:33,680 --> 01:59:36,230
on the swarm manager and that will

2637
01:59:36,230 --> 01:59:38,690
initialize the swamp manager the output

2638
01:59:38,690 --> 01:59:41,180
will also provide the command to be run

2639
01:59:41,180 --> 01:59:43,790
on the workers so copy the command and

2640
01:59:43,790 --> 01:59:45,890
run it on the worker nodes to join the

2641
01:59:45,890 --> 01:59:48,320
manager after joining the swamp the

2642
01:59:48,320 --> 01:59:50,600
workers are also referred to as nodes

2643
01:59:50,600 --> 01:59:53,150
and you're now ready to create services

2644
01:59:53,150 --> 01:59:56,630
and deploy them on the swamp cluster so

2645
01:59:56,630 --> 01:59:59,600
let's get into some more details as you

2646
01:59:59,600 --> 02:00:02,450
already know to run an instance of my

2647
02:00:02,450 --> 02:00:03,410
web server

2648
02:00:03,410 --> 02:00:06,500
I run the docker run command and specify

2649
02:00:06,500 --> 02:00:09,110
the name of the image I wish to run this

2650
02:00:09,110 --> 02:00:11,360
creates a new container instance of my

2651
02:00:11,360 --> 02:00:14,600
application and serves my web server now

2652
02:00:14,600 --> 02:00:16,040
that we have learned how to create a

2653
02:00:16,040 --> 02:00:18,260
swamp cluster how do I utilize my

2654
02:00:18,260 --> 02:00:20,600
cluster to run multiple instances of my

2655
02:00:20,600 --> 02:00:23,030
web server now one way to do this would

2656
02:00:23,030 --> 02:00:25,430
be to run the docker run command on each

2657
02:00:25,430 --> 02:00:27,739
worker node but that's not ideal as I

2658
02:00:27,739 --> 02:00:30,110
might have to log into each node and run

2659
02:00:30,110 --> 02:00:32,150
this command and there there could be

2660
02:00:32,150 --> 02:00:34,310
hundreds of nodes I will have to set up

2661
02:00:34,310 --> 02:00:36,290
load balancing myself a large monitor

2662
02:00:36,290 --> 02:00:38,810
the state of each instance myself and if

2663
02:00:38,810 --> 02:00:41,239
instances were to fail I'll have to

2664
02:00:41,239 --> 02:00:43,100
restart them myself so it's going to be

2665
02:00:43,100 --> 02:00:45,950
an impossible task that is where docker

2666
02:00:45,950 --> 02:00:48,270
swarm orchestration consent

2667
02:00:48,270 --> 02:00:50,760
dr. Swan Orchestrator does all of this

2668
02:00:50,760 --> 02:00:53,850
for us so far we've only set up this one

2669
02:00:53,850 --> 02:00:55,290
cluster but we haven't seen

2670
02:00:55,290 --> 02:00:57,480
orchestration in action the key

2671
02:00:57,480 --> 02:00:59,940
component of suam orchestration is the

2672
02:00:59,940 --> 02:01:01,710
Ducker a service

2673
02:01:01,710 --> 02:01:04,920
dr. services are one or more instances

2674
02:01:04,920 --> 02:01:07,080
of a single application or service that

2675
02:01:07,080 --> 02:01:09,630
runs across the song the nodes in the

2676
02:01:09,630 --> 02:01:12,150
song cluster for example in this case I

2677
02:01:12,150 --> 02:01:14,250
could create a docker service to run

2678
02:01:14,250 --> 02:01:16,530
multiple instances of my web server

2679
02:01:16,530 --> 02:01:19,200
application across worker nodes in my

2680
02:01:19,200 --> 02:01:21,900
swamp cluster for this around the docker

2681
02:01:21,900 --> 02:01:24,300
service create command on the manager

2682
02:01:24,300 --> 02:01:26,790
node and specify my image name there

2683
02:01:26,790 --> 02:01:29,700
which is my web server in this case and

2684
02:01:29,700 --> 02:01:32,280
use the option replicas to specify the

2685
02:01:32,280 --> 02:01:34,710
number of instances of my web server I

2686
02:01:34,710 --> 02:01:36,420
would like to run across the cluster

2687
02:01:36,420 --> 02:01:40,680
since I specified 3 replicas and I get 3

2688
02:01:40,680 --> 02:01:43,440
instances of my web server distributed

2689
02:01:43,440 --> 02:01:45,530
across the different worker nodes

2690
02:01:45,530 --> 02:01:48,780
remember the docker service command must

2691
02:01:48,780 --> 02:01:51,120
be run on the manager node and not on

2692
02:01:51,120 --> 02:01:53,190
the worker node the docker service

2693
02:01:53,190 --> 02:01:55,320
create command is similar to the docker

2694
02:01:55,320 --> 02:01:57,360
run command in terms of the options

2695
02:01:57,360 --> 02:01:59,910
passed such as the - e environment

2696
02:01:59,910 --> 02:02:02,520
variable the - key for publishing ports

2697
02:02:02,520 --> 02:02:05,340
the network option to attach container

2698
02:02:05,340 --> 02:02:08,370
to a network etc well that's a

2699
02:02:08,370 --> 02:02:10,110
high-level introduction to dr. Swan

2700
02:02:10,110 --> 02:02:12,570
there's a lot more to know such as

2701
02:02:12,570 --> 02:02:14,640
configuring multiple managers overlay

2702
02:02:14,640 --> 02:02:17,400
networks etc as I mentioned it requires

2703
02:02:17,400 --> 02:02:20,550
its own separate course well that's it

2704
02:02:20,550 --> 02:02:23,220
for now in the next lecture we will look

2705
02:02:23,220 --> 02:02:26,400
at kubernetes at a higher level

2706
02:02:26,400 --> 02:02:30,419
[Music]

2707
02:02:30,419 --> 02:02:32,579
we will now get a brief introduction to

2708
02:02:32,579 --> 02:02:34,919
basic kubernetes concepts again

2709
02:02:34,919 --> 02:02:38,130
kubernetes requires its own course well

2710
02:02:38,130 --> 02:02:41,280
a few courses at least five but we will

2711
02:02:41,280 --> 02:02:43,169
try to get a brief introduction to it

2712
02:02:43,169 --> 02:02:46,409
here with docker you were able to run a

2713
02:02:46,409 --> 02:02:48,869
single instance of an application using

2714
02:02:48,869 --> 02:02:51,899
the docker CLI by running the docker run

2715
02:02:51,899 --> 02:02:54,599
command which is grid running an

2716
02:02:54,599 --> 02:02:56,999
application has never been so easy

2717
02:02:56,999 --> 02:03:00,149
before with kubernetes using the

2718
02:03:00,149 --> 02:03:03,449
kubernetes CLI known as cube control you

2719
02:03:03,449 --> 02:03:05,880
can run a thousand instance of the same

2720
02:03:05,880 --> 02:03:07,999
application with a single command

2721
02:03:07,999 --> 02:03:11,010
kubernetes can scale it up to two

2722
02:03:11,010 --> 02:03:13,590
thousand with another command kubernetes

2723
02:03:13,590 --> 02:03:15,689
can be even configured to do these

2724
02:03:15,689 --> 02:03:18,239
automatically so that instances and the

2725
02:03:18,239 --> 02:03:20,729
infrastructure itself can scale up and

2726
02:03:20,729 --> 02:03:24,389
down based on user load kubernetes can

2727
02:03:24,389 --> 02:03:27,659
upgrade these 2000 instances of the

2728
02:03:27,659 --> 02:03:30,630
application in a rolling upgrade fashion

2729
02:03:30,630 --> 02:03:33,419
one at a time with a single command if

2730
02:03:33,419 --> 02:03:35,369
something goes wrong it can help you

2731
02:03:35,369 --> 02:03:37,439
roll back these images with a single

2732
02:03:37,439 --> 02:03:40,260
command kubernetes can help you test new

2733
02:03:40,260 --> 02:03:42,869
features of your application by only

2734
02:03:42,869 --> 02:03:44,969
upgrading a percentage of these

2735
02:03:44,969 --> 02:03:47,639
instances through a be testing methods

2736
02:03:47,639 --> 02:03:49,739
the kubernetes open architecture

2737
02:03:49,739 --> 02:03:52,979
provides support for many many different

2738
02:03:52,979 --> 02:03:55,860
network and storage vendors any network

2739
02:03:55,860 --> 02:03:58,139
or storage brand that you can think of

2740
02:03:58,139 --> 02:04:01,439
has a plugin for kubernetes kubernetes

2741
02:04:01,439 --> 02:04:03,899
supports a variety of authentication and

2742
02:04:03,899 --> 02:04:06,780
authorization mechanisms all major cloud

2743
02:04:06,780 --> 02:04:08,849
service providers have native support

2744
02:04:08,849 --> 02:04:12,419
for kubernetes so what's the relation

2745
02:04:12,419 --> 02:04:15,119
between docker and kubernetes well

2746
02:04:15,119 --> 02:04:17,929
kubernetes uses docker host to host

2747
02:04:17,929 --> 02:04:20,249
applications in the form of docker

2748
02:04:20,249 --> 02:04:23,340
containers well it need not be docker

2749
02:04:23,340 --> 02:04:24,329
all the time

2750
02:04:24,329 --> 02:04:26,519
kubernetes supports as relatives to

2751
02:04:26,519 --> 02:04:29,630
Dockers as well such as rocket or a cryo

2752
02:04:29,630 --> 02:04:31,739
but let's take a quick look at the

2753
02:04:31,739 --> 02:04:34,409
kubernetes architecture a kubernetes

2754
02:04:34,409 --> 02:04:38,039
cluster consists of a set of nodes let

2755
02:04:38,039 --> 02:04:41,039
us start with nodes in node is a machine

2756
02:04:41,039 --> 02:04:43,320
physical or virtual on which a cobranet

2757
02:04:43,320 --> 02:04:44,070
is

2758
02:04:44,070 --> 02:04:46,500
Karina's software a set of tools are

2759
02:04:46,500 --> 02:04:49,409
installed a node is a worker machine and

2760
02:04:49,409 --> 02:04:51,150
that is where containers will be

2761
02:04:51,150 --> 02:04:54,000
launched by kubernetes but what if the

2762
02:04:54,000 --> 02:04:55,590
node on which the application is running

2763
02:04:55,590 --> 02:04:57,780
fails well obviously our application

2764
02:04:57,780 --> 02:05:00,060
goes down so you need to have more than

2765
02:05:00,060 --> 02:05:02,880
one nodes a cluster is a set of nodes

2766
02:05:02,880 --> 02:05:05,429
grouped together this way even if one

2767
02:05:05,429 --> 02:05:07,079
node fails you have your application

2768
02:05:07,079 --> 02:05:10,340
still accessible from the other nodes

2769
02:05:10,340 --> 02:05:13,409
now we have a cluster but who is

2770
02:05:13,409 --> 02:05:15,780
responsible for managing this cluster

2771
02:05:15,780 --> 02:05:17,429
where's the information about the

2772
02:05:17,429 --> 02:05:19,710
members of the cluster stored how are

2773
02:05:19,710 --> 02:05:22,409
the nodes monitored when a node fails

2774
02:05:22,409 --> 02:05:24,300
how do you move the workload of the

2775
02:05:24,300 --> 02:05:26,310
failed nodes to another worker node

2776
02:05:26,310 --> 02:05:29,579
that's where the master comes in the

2777
02:05:29,579 --> 02:05:31,619
master is a note with the kubernetes

2778
02:05:31,619 --> 02:05:34,739
control plane components installed the

2779
02:05:34,739 --> 02:05:37,349
master watches over the nodes are in the

2780
02:05:37,349 --> 02:05:39,540
cluster and is responsible for the

2781
02:05:39,540 --> 02:05:42,239
actual orchestration of containers on

2782
02:05:42,239 --> 02:05:44,400
the worker nodes when you install

2783
02:05:44,400 --> 02:05:47,400
kubernetes on a system you're actually

2784
02:05:47,400 --> 02:05:49,380
installing the following components an

2785
02:05:49,380 --> 02:05:53,579
API server and EDD server a cubelet

2786
02:05:53,579 --> 02:05:56,760
service contain a runtime engine like

2787
02:05:56,760 --> 02:05:59,639
docker and a bunch of controllers and

2788
02:05:59,639 --> 02:06:03,090
the scheduler the API server acts as the

2789
02:06:03,090 --> 02:06:05,310
front end for kubernetes the users

2790
02:06:05,310 --> 02:06:07,409
management devices command line

2791
02:06:07,409 --> 02:06:10,290
interfaces all talk to the API server to

2792
02:06:10,290 --> 02:06:12,090
interact with the kubernetes cluster

2793
02:06:12,090 --> 02:06:14,760
next is the Etsy be a key value store

2794
02:06:14,760 --> 02:06:17,489
the Etsy D is a distributed reliable key

2795
02:06:17,489 --> 02:06:20,040
value store used by kubernetes to store

2796
02:06:20,040 --> 02:06:22,290
all data used to manage the cluster

2797
02:06:22,290 --> 02:06:24,329
think of it this way when you have

2798
02:06:24,329 --> 02:06:26,849
multiple nodes and multiple masters in

2799
02:06:26,849 --> 02:06:29,190
your cluster let CD stores all that

2800
02:06:29,190 --> 02:06:30,869
information on all the nodes in the

2801
02:06:30,869 --> 02:06:33,570
cluster in a distributed manner and CD

2802
02:06:33,570 --> 02:06:36,540
is responsible for implementing a locks

2803
02:06:36,540 --> 02:06:38,159
within the cluster to ensure there are

2804
02:06:38,159 --> 02:06:41,099
no conflicts between the masters the

2805
02:06:41,099 --> 02:06:42,599
scheduler is responsible for

2806
02:06:42,599 --> 02:06:44,699
distributing work or containers across

2807
02:06:44,699 --> 02:06:47,250
multiple nodes it looks for newly

2808
02:06:47,250 --> 02:06:49,469
created containers and assigns them to

2809
02:06:49,469 --> 02:06:52,559
notes the controllers are the brain

2810
02:06:52,559 --> 02:06:54,809
behind orchestration they're responsible

2811
02:06:54,809 --> 02:06:57,340
for noticing and responding when

2812
02:06:57,340 --> 02:06:59,830
notes containers or endpoints goes down

2813
02:06:59,830 --> 02:07:02,800
the controllers makes decisions to bring

2814
02:07:02,800 --> 02:07:05,349
up new containers in such cases the

2815
02:07:05,349 --> 02:07:07,389
container runtime is the underlying

2816
02:07:07,389 --> 02:07:09,849
software that is used to run containers

2817
02:07:09,849 --> 02:07:12,420
in our case it happens to be docker and

2818
02:07:12,420 --> 02:07:15,400
finally cubelet is the agent that runs

2819
02:07:15,400 --> 02:07:18,070
on each node in the cluster the agent is

2820
02:07:18,070 --> 02:07:20,170
responsible for making sure that the

2821
02:07:20,170 --> 02:07:22,750
containers are running on the notes as

2822
02:07:22,750 --> 02:07:25,540
expected and finally we also need to

2823
02:07:25,540 --> 02:07:27,429
learn a little bit about one of the

2824
02:07:27,429 --> 02:07:29,949
command-line utilities known as the cube

2825
02:07:29,949 --> 02:07:32,139
command-line tool or the cube control

2826
02:07:32,139 --> 02:07:34,480
tool or cube cuddle as it is also called

2827
02:07:34,480 --> 02:07:37,780
the cube control tool is the kubernetes

2828
02:07:37,780 --> 02:07:40,239
CLI which is used to deploy and manage

2829
02:07:40,239 --> 02:07:42,969
applications on a convergence cluster to

2830
02:07:42,969 --> 02:07:45,130
get cluster related information to get

2831
02:07:45,130 --> 02:07:46,570
the status with the nodes in the cluster

2832
02:07:46,570 --> 02:07:49,869
and many other things the cube control

2833
02:07:49,869 --> 02:07:52,000
run command is used to deploy an

2834
02:07:52,000 --> 02:07:54,099
application on the cluster the keep

2835
02:07:54,099 --> 02:07:56,050
control cluster info command is used to

2836
02:07:56,050 --> 02:07:58,000
view information about the cluster and

2837
02:07:58,000 --> 02:08:00,489
the cube control get nodes command is

2838
02:08:00,489 --> 02:08:02,440
used to list all the nodes part of the

2839
02:08:02,440 --> 02:08:05,710
cluster so to run hundreds of instances

2840
02:08:05,710 --> 02:08:07,780
of your application across hundreds of

2841
02:08:07,780 --> 02:08:10,690
nodes all I need is a single kubernetes

2842
02:08:10,690 --> 02:08:14,020
command like this well that's all we

2843
02:08:14,020 --> 02:08:16,270
have for now a quick introduction to

2844
02:08:16,270 --> 02:08:18,730
Cornelis and its architecture we

2845
02:08:18,730 --> 02:08:20,860
currently have three courses on code

2846
02:08:20,860 --> 02:08:24,070
cloud on kubernetes that will take you

2847
02:08:24,070 --> 02:08:26,139
from the absolute beginner to a

2848
02:08:26,139 --> 02:08:29,380
certified expert so have a look at it

2849
02:08:29,380 --> 02:08:30,400
when you get a chance

2850
02:08:30,400 --> 02:08:34,539
[Music]

2851
02:08:34,539 --> 02:08:37,189
so we're at the end of this beginners

2852
02:08:37,189 --> 02:08:39,559
course to docker I hope you had a great

2853
02:08:39,559 --> 02:08:42,019
learning experience if so please leave a

2854
02:08:42,019 --> 02:08:44,869
comment below if you like my way of

2855
02:08:44,869 --> 02:08:47,209
teaching you will love my other courses

2856
02:08:47,209 --> 02:08:50,030
hosted on my site at code cloud we have

2857
02:08:50,030 --> 02:08:52,449
courses for docker swarm kubernetes

2858
02:08:52,449 --> 02:08:54,769
advanced courses on kubernetes

2859
02:08:54,769 --> 02:08:57,679
certifications as well as OpenShift we

2860
02:08:57,679 --> 02:08:59,809
have courses for automation tools like

2861
02:08:59,809 --> 02:09:03,019
Antigo chef and puppet and many more on

2862
02:09:03,019 --> 02:09:07,209
the way with it code cloud at

2863
02:09:09,010 --> 02:09:12,010
www.calculated.com/support

2864
02:09:14,030 --> 02:09:22,649
[Music]

